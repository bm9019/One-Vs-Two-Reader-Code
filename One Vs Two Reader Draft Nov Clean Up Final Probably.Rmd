---
title: One Vs Two reader Stuff
output:
  officedown::rdocx_document:
    reference_docx: word-style5.docx
  page_size:
    width: 8.3
    height: 11.7
    orient: "portrait"
  page_margins:
    bottom: .7
    top: .7
    right: .7
    left: .7
    header: 0
    footer: 0
    gutter: 0
---





<!-- Load Packages -->
```{r Packages, results='hide', message=FALSE, warning=FALSE, echo = FALSE}

#This lists a bunch of libraries, I am probably not actually using all of these
library(dplyr, warn.conflicts = FALSE)
library(forestmangr)
library(ggplot2) #install.packages('highr', dep = TRUE)
#install.packages('backports')
#install.packages('stargazer')
#install.packages("devtools")
#devtools::install_github('rstudio/rmarkdown')
library(data.table)
#install.packages("xfun")
library(psych)
library(stats)
library(xaringan)
library(stargazer) 
library(xtable) 
library(pander)
library(flextable) 
#library(doBy)
library(sjlabelled) 
library(tableone)
#library(Hmisc)
#library(devtools)
library(ggthemes) 
library(RColorBrewer)
#library(ggExtra)
#library(DiagrammeR)
#library(DiagrammeRsvg)
library(rsvg)
#library(magrittr)
library(scales)
#library(knitr)
#install.packages("gtsummary")
library(gtsummary) 
#library(htmltools)
library(pagedown)
library(readxl)
#library(data.table)
library(tidyr)
library(labelled)
library(plyr)
#install.packages("slider")
library(slider)
#remotes::install_github("noamross/redoc")

#install.packages("whoami")
#install.packages("broom.helpers")
library(rstatix) 
library(lsr) 
library(effsize)
library(gtools)
library(crosstable)

library(optmatch)
library(RItools)
library(table1)
library(pglm)
# library(plotly)
#library("vioplot")

#install.packages("sm")
library(sjPlot)
library(sjmisc)
library(sjlabelled)

#install.packages("survival")
library(survival)

#library(purrr)
#install.packages("patchwork")
library(RVAideMemoire)

library(ranger)
library(ggfortify)

library(patchwork)
 
library(ggsignif)
library(ggpubr)
#install.packages("survminer")
library(survminer)
 library(janitor)

#install.packages("lm.beta")
library(performance)
library(MASS)
 #library(tab)
#library(QuantPsyc)
library(lm.beta)
library(car)
# library(DiagrammeR)
#install.packages("cmprsk")
library(cmprsk)

library("stringr") 

#install.packages("microbenchmark")
library(microbenchmark)
#install.packages("fst")
library(fst)

library(lubridate)
#install.packages("datasummary")
library(modelsummary)


library(MuMIn)
#library(stringi)
library(labelled)
# library(expss)
  library(ggh4x)

library(lme4)

library(scales)    
library(survival)
library(survminer)

 #install.packages("cmprsk")
 library(cmprsk)
 #install.packages("broom.mixed")
 library(ggsurvfit)
library(broom.mixed)
library(finalfit)
library(xlsx)

#install.packages("lmerTest")
library(lmerTest)

#This option helps prevent kableExtra from messing up table format for kable tables 
options(kableExtra.auto_format = FALSE) 
library(kableExtra)
library(ordinal)
#remove.packages("rlang")
library(binom)

#This option presents scientific notation
options(scipen=999)


#This option sets typical font for flex tables
set_flextable_defaults(font.family = "Time New Roman", font.size = 9)


```






```{r Setup, include=FALSE}
#This line is needed for some reason
knitr::opts_chunk$set(echo = TRUE)

#This sets gtsummary options
options(gtsummary.print_engine = "kable")





#This tries to get comas added to longer numbers for clarity
knitr::knit_hooks$set(inline = function(x) {   if(!is.numeric(x)){     x   }else{    prettyNum(round(x,2), big.mark=",")    } })


#This starts time for timing code
startcode <- Sys.time()


#This tries to increase the memory limit for R to prevent memory errors, I don't know if it actually works 
 memory.limit(size=32768)

 
 
 #This allows for changing how many rows are read in from the full dataset. This was done due to being able to
 #change this option for testing tables and models to see if they run faster and then changing to the full data
  fromnum <- 1
  tonum <- 53471265


 


  #This is just a command to more easily allow for filter based on if a variable is not in a list
`%notin%` <- Negate(`%in%`)



#The article wants round to even, we also want to be able to give more digits to smaller numbers, this rounding function allows for this
RRound <- function(x){
  ifelse(abs(x) < .001, sprintf('%.5f', x),
     ifelse(abs(x) < .01, sprintf('%.4f', x),  
        ifelse(abs(x) < .1, sprintf('%.3f', x),  sprintf('%.2f', x)
         )))
}


#This function similar to the above but because the tbl_summary command changes proportion to percentages internally the *100 was added to make sure rounding would work for tbl_summary percentages right
RRound2 <- function(x){
  ifelse(abs(x) < .00001, sprintf('%.5f', x*100),
     ifelse(abs(x) < .0001, sprintf('%.4f', x*100),  
        ifelse(abs(x) < .001, sprintf('%.3f', x*100),  sprintf('%.2f', x*100)
         )))
}



#Table and figure numbers are automatically numbered so that if tables and figures are moved around the order number is updated automatically, here figure numbering starts at 2 as there is another figure not produced in r that is the first figure in the paper, I also think we eventually just numbered figures and tables by ourselves so this no longer matches up properly
tablenum <- 1
fignum <- 3


#This is a list of film reader ids that were "consensus" readers, this is used when determining numbers for "valid" film readers
conlist <- data.table::fread("C:\\Users\\u4111872\\Downloads\\UGH\\Lookover\\conlist.csv")
conlist <- unique(conlist$FILMREADERID)

#Certain film reader IDs were not IDs that were connected with individual readers but instead IDs that served as placeholders for missing IDs or IDs for saying it was a trainee or things like that. This imports that list
nameless <- data.table::fread("C:\\Users\\u4111872\\Downloads\\UGH\\Lookover\\nameless.csv")
nameless <- unique(nameless$FILMREADER)

#This reads in the results from the "allsubsets" chunk of code. Because there was a lot of different subgroups of data this chunk determine which subgroups were to be analysed in advance and created ID lists. This allowed for easier filtering of screens when running analysis within loops. The code to generate this list is elsewhere
SubsetList <- read.csv("SubsetList.csv")

```



# One vs Two Draft


```{r 1v2readerbycentregraphdatagenerationandgraph, out.width='100%', results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE, eval = TRUE, fig.align="center"}


#The data was split into three fst file. This is due to the largest of the files that prevented the whole data and whole list of variable being read in at the same time as it would cause the computer to crash. Later, I was given access to a computer that could actually have the whole file opened once without crashing so the dastasets were joined back together but the code below still tends to read in and join together different datasets


#This is a list of columns I want from the fst file
creadlist <- c( "EPISODEID", "PATIENTID", "OfficeID", "ReaderNum4")

#This reads in one of the files, subsets the columns wanted, and the fromnum and tonum relate to if I am running this draft on the full dataset or on a smaller testing sample
table2 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst", columns = creadlist, from = fromnum, to = tonum)

#This is a list of exclusions, basically the EPSIODEID is the unique number used for screenings and this filters our screens that have been added to the exclusion list, you can read more the exclusions here: https://academic.oup.com/bjr/article/97/1153/98/7470406
#The file to calculate exclusions can also be found in the ExclusionsOnly File
exclusion <- read.csv("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\episodeexcludelist.csv")
table2 <- table2 %>% filter(EPISODEID %notin% exclusion$EPISODEID)

#This is a similar method of reading in the data. Don't need to use exclusions here as it is being left joined to the dataset (table2) that already has exclusions. This dataset reading in will repeat throughout the paper as, due to memory and computer limitations, we had to keep deleting and bringing back in the data rather than just read it all in at once and keep the dataset loaded that way, this also allows us to turn chunks on and off easier and to save data and graphs elsewhere rather than having to rerun the analysis in every draft
  creadlist <- c("screeningdate", "dateoffirstofferedappointmentcalc", "EPISODEID")
    readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst"
table2b <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)


#This imports a section of the dataset that is patient level rather than screen level, here we are interested in assessing linking quality as in earlier years before adoption of NHS numbers it is harder to link pateints across dataset, the below code gets that information and joins it to table2 by PATIENTID
 creadlist <- c("PATIENTID",  "INVALIDNHSNUMBER")
table0 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\Table0.fst", columns = creadlist)

#Adds labels to the number variables
table0$INVALIDNHSNUMBER <- factor(table0$INVALIDNHSNUMBER,
levels = c(0,2,3),
labels = c("Valid # from NBSS", "Valid # from Tracing", "Invalid #"))

#join to table 2, this match command is a less well known way for left joining than other commands but it is faster than merging which is why it was used
table2$INVALIDNHSNUMBER = table0$INVALIDNHSNUMBER[match(table2$PATIENTID, table0$PATIENTID)]

#remove table not needed to clear up memory and space
rm(table0)



#Since different variables are kept in three different datasets due to the memory problems mentioned, those variables often need to be joined into one dataset, this matched the two different datasets into the main dataset referred usually as table 2, the matching is done by the unique EPISODEID mentioned previously
table2$screeningdate = table2b$screeningdate[match(table2$EPISODEID, table2b$EPISODEID)]


#This removes the table now that the variables needed are matched, again, trying to keep as little data loaded as possible to prevent memory errors and crashes
remove(table2b)



#For most of the paper we use something called "dateoffirstofferedappointmentcalc", this is or most lenient measure of date where we take the date of first offered appointment, then if that is missing the date of screening, and then if that is missing the date of screen being taken. All these dates are the same for a very large percent of the time but there are some cases where they are different or some date info would be missing for one, this allows for the most number of screens to be included. However, for some analysis and calculation where date is specifically of interest and not just something to control for a less complete but more accurate date is used. Here, we are most interested in the date tied to the screening date and don't want to replace that date if it is NA, this gets the year from the screening date
table2$SY <- lubridate::year(table2$screeningdate)


#ReaderNum4 is a calculated variable. There are three columns that relate to film reader reactions and this code adds up the number of columns with some data in them as a way to count how many film readers there are. Additionally, this code also subtracts those number of actions by the number of consensus reader IDs listed if there are any. This was used because sometimes there would be reader actions but not reader IDs or screens with reader IDs but no action. For most of the data, there is both a reader ID and a reaction however. Consensus readers were not included in the count of film readers. This variable changes reader number into a binary less than 2 and greater than 2
table2$Twoplus <- ifelse(table2$ReaderNum4 < 2, 0, 1)


#This creates a frame which gets the total number of screens by Year and OfficeID
nn=xtabs(~OfficeID+SY,table2[which(!is.na(table2$screeningdate)),])

#This then counts up the total number of 2 or more reader screens by office id and year and divide by total to be a proportion of two reader screens
f <- xtabs(Twoplus~OfficeID+SY,table2[which(!is.na(table2$screeningdate)),])/nn

#Rounding this number
f <- round(f, digits = 2)

#Putting the frames as a dataframe to make them more managable
nn <- as.data.frame(nn)
f <- as.data.frame(f)

#Creating an office and year ID to be able to link the frames
f$OfficeYear <- paste0(f$OfficeID, "-", f$SY)
nn$OfficeYear <- paste0(nn$OfficeID, "-", nn$SY)

#Linked total number to the frame with 2 reader proportion 
f$Total = nn$Freq[match(f$OfficeYear, nn$OfficeYear)]

#Don't need this anymore
f$OfficeYear <- NULL

#The above code used to run very slowly because I was on a slower computer so I exported the data so I didn't have to run it everytime I ran the draft
write.csv(f, "C:\\Users\\u4111872\\Downloads\\UGH\\Lookover\\avgreadernumbycentreScreeningDate.csv")


#This reads the dataset back in
fig <- read.csv("C:\\Users\\u4111872\\Downloads\\UGH\\Lookover\\avgreadernumbycentreScreeningDate.csv")

#We are filtering out centre-years with less than 100 screens and keeping only relevant columns
fig <- fig %>% filter(Total > 99) %>% dplyr::select(OfficeID, SY, Freq)

#The years after 2009 are largely 100% all two reader so to get the graph to be more concise we excluded those
stupidyear <- c("2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018")
fig <- fig %>% filter(SY %notin% stupidyear)

#There were some centres that had issues with data collection as mentioned in the exclusions, however, to keep a woman's complete history in (so she may have been screen at an included centre, then screened at an excluded centre) screenings with women who attended at least one centre that wasn't excluded had all screens kept in even if one of those screen would have been at the excluded centre. Due to this, whenever we are specifically looking at centre level variables like here, we have to filter these out
stupidcentres <- c("S032", "S077", "S084")
fig <- fig %>% filter(OfficeID %notin% stupidcentres)


#We are also interested in how quality of linkage varies by year so we are getting a percent of non-valid NHS numbers by year measure below

#This creates a variable that is just if a screening was related to a patient with a valid ID for linking or not 
table2$ValidNHS <- ifelse(table2$INVALIDNHSNUMBER == "Valid # from NBSS", 1, 0)

#This creates a table that counts valid and non valid NHS number screens by year
ValidNHStable <- as.data.frame.matrix(table(table2$SY, table2$ValidNHS))

#Because matrix converts first column to row names need to reverse that back
ValidNHStable <- tibble::rownames_to_column(ValidNHStable, "SY")

#Create total column
ValidNHStable$Total <- ValidNHStable$`0` + ValidNHStable$`1`

#Create proportion valid
ValidNHStable$Prop <- ValidNHStable$`1`/ValidNHStable$Total

#Join that to fig table
fig$Prop = ValidNHStable$Prop[match(fig$SY, ValidNHStable$SY)]



#This is a way to save the ggplot graph as a image which is clear and can be put in the draft later which can also allow for this chunk of code to be commented out 
 jpeg("C:\\Users\\u4111872\\Downloads\\UGH\\graphs\\DateCalc1vs2ReaderCentre.png", width = 2700, height = 1100, res=300)

 #This is a pretty basic plot using centre as the unit of analysis and looking proportion of two reader screens by year
     p <- ggplot(fig, aes(x=as.factor(SY), y=Freq)) + 
  geom_boxplot() +    geom_line(aes(x = as.factor(SY), y = Prop, group = 1),  size = 1)  
  p <-  p + stat_summary(fun.y=mean, geom="point", shape=23, size=4) +labs(title = paste0("Proportion of screens read by two readers by centre (box plots) and propotion of screens \n with a patient that had a valid NHS number for linking (line)"),
         x ="Screening year", y = "Proportion") + theme_classic() + scale_fill_brewer(palette = "Set2") 
  p + theme(legend.position="bottom", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))    # Secondary y-axis (for the line)
  
 
#This is related to saving the ggplot graph as an image  
invisible(dev.off())



#this cleans up 
rm(p, f, fig, fig1, fig2, table2, nn)


```



Descriptives by one and two reader for 1994-1999. These years were chosen because it is the years where less than 10% of readers had tracing issues and where the percentage of 1 vs 2 reader screens for that year has a percent difference less than 5% (so 48% one reader bs 52% two reader screens for instance).This can be seen in Figure `r fignum`. 

![](C:\\Users\\u4111872\\Downloads\\UGH\\graphs\\DateCalc1vs2ReaderCentre.png)


```{r Dataimport2, out.width='100%', results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}

#Above is the first figure so I add 1 to figure number
fignum <- fignum + 1



#Reads in columns from the patient level dataset, FirstScreenID is the EPISODEID where it was a patient's first screen, this allows us to categorise screens into if it was a women's first screen or not, LastAgeOffered is the oldest age in the dataset that a screen has been offered
  creadlist <- c("PATIENTID", "FirstScreenID", "IMDQUINTILE", "YEAROFDEATH")
table0 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\Table0.fst", columns = creadlist)

#If there is a Year then create a binary died variable for this patient
table0$Died <- ifelse(!is.na(table0$YEAROFDEATH), "Yes", "No")

#Reads in variables from one of the screening datasets
    creadlist <- c( "EPISODEID", "PATIENTID", "OfficeID", "CANCEROUTCOMEFLAG", "dateoffirstofferedappointmentcalc",  "AgeCalc", "Screened", "Attender3", "datetakencalc")
    readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst"
table2 <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

#Exclusion file import, the exclusion and calculation of this csv file can be found in the ExclusionsOnly file
exclusion <- read.csv("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\episodeexcludelist.csv")

#Get year from date
table2$Year <- lubridate::year(table2$dateoffirstofferedappointmentcalc)

#Exclusion file filtering
table2 <- table2 %>% filter(EPISODEID %notin% exclusion$EPISODEID)

#Matching patient table with screening data
      table2$IMDQUINTILE = table0$IMDQUINTILE[match(table2$PATIENTID, table0$PATIENTID)]
       table2$FirstScreenID = table0$FirstScreenID[match(table2$PATIENTID, table0$PATIENTID)]
       table2$Died  = table0$Died[match(table2$PATIENTID, table0$PATIENTID)]
       table2$YEAROFDEATH = table0$YEAROFDEATH[match(table2$PATIENTID, table0$PATIENTID)]
       
     

#This classifies screen type on if it was prevalent (first screen for a women) or incident (not first screen)
table2$ScreenType <- ifelse(table2$EPISODEID %in% table0$FirstScreenID, "Prevalent",   "Incident"    )


#clean up
rm(exclusion)

#More linking, since we are left joining to dataset that has already been filter for exclusions no need to filter for exclusions again 
  readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst"
 creadlist <- c("EPISODEID",  "ReaderNum4")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2$ReaderNum4 = table2a$ReaderNum4[match(table2$EPISODEID, table2a$EPISODEID)]
 rm(table2a)

   readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst"
 creadlist <- c("EPISODEID",  "Recall", "FalsePositiveRecall")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2$Recall = table2a$Recall[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$FalsePositiveRecall = table2a$FalsePositiveRecall[match(table2$EPISODEID, table2a$EPISODEID)]
 rm(table2a)


 #This creates a numerical cancer variable, ever screen has either Y or N in the data even if they didn't get screened (so it would be N) 
 table2$Cancer <- ifelse(table2$CANCEROUTCOMEFLAG == "Y", 1,
                    ifelse(table2$CANCEROUTCOMEFLAG == "N", 0,  NA    ))

#For both of these variables, there is only data for screened screenings, this changes it so that non-screened screenings defaults to no recall and no false positive  
table2$Recall <- ifelse(table2$Recall == 1, 1, 0)
table2$FalsePositiveRecall <- ifelse(table2$FalsePositiveRecall == 1, 1, 0)


#This changes the readernum to be either a one reader or more than one reader (mostly two reader) group
 table2$Group <- ifelse(table2$ReaderNum4 == 1, "One reader", ifelse(table2$ReaderNum4 > 1, "More than one reader", NA))
 
#Since we are using centre ID as a random effect and we have rare outcomes, there are some instance were a certain outcome and certain reader groups don't have that outcome and convergence issues happen, for centres with less than 100k screenings they were grouped with the centre that was most likely to be the 2nd used centre of patients in that centre (so for the patients that attended multiple centres and was in centre S032, one of our excluded centres, we found the most commonly attended centre was S006). There were also three centres that still had small sample sizes in certain instance despite have more than 100k screens (S027, S061, S007) so those were group as well. This OfficeID1Plus was then used as a random effect
 table2$OfficeID1Plus <- ifelse(table2$OfficeID == "S032", "S006",
                          ifelse(table2$OfficeID == "S050", "S009",
                              ifelse(table2$OfficeID == "S077", "S079",
                                  ifelse(table2$OfficeID == "S078", "S071",
                                    ifelse(table2$OfficeID == "S081", "S071",
                                        ifelse(table2$OfficeID == "S083", "S021",
                                          ifelse(table2$OfficeID == "S084", "S079",
                                              ifelse(table2$OfficeID == "S027", "S023",
                                                  ifelse(table2$OfficeID == "S061", "S015",
                                                      ifelse(table2$OfficeID == "S007", "S074", table2$OfficeID
                                                              ))))))))))


#Table 4 is the cancer registry data with some addition variable calculation (the additional calcutions can be see in the FrankenCode)
table4 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table4.fst")
 
#This adds text label to cancer types 
     table4$Type <- ifelse(table4$SDDCISInvasive == 1, "DCIS",
                                ifelse(table4$SDDCISInvasive == 2, "Invasive", "Missing"))


   #Refactors some of the cancer variables to have grades go from most severe cancers to least severe
    table4$SDInvasiveGrade2 <- factor(table4$SDInvasiveGrade, levels = c("G3", "G2", "G1", "GX", "Other", "Miscode", "Missing", "DCIS"))
    table4$SDDCISGrade2 <- factor(table4$SDDCISGrade, levels = c("GH", "GI", "GL", "GX", "Other", "Miscode", "Missing", "Invasive"))

    
#Working on a table4 back up for next bit of code
table4sub <- table4 

#EPISODEIDLink is the Episode that is closest to before a cancer (adding 7 days to account for a week time of leeway, so if the cancer was diagnosed a few days before the screening episode this would still be considered the closest after cancer diagnosis screen), because multiple cancers can be diagnosed per screening (this is quite rare) and we wanted to look at one cancer per screening we prioritized looking at invasive and severe cancers
 table4sub <- table4sub   %>%  group_by(EPISODEIDLink)  %>% arrange(EPISODEIDLink,  desc(ScreenedTumor), desc(SDDCISInvasive), SDInvasiveGrade2, SDDCISGrade2, desc(SDInvasiveSize), desc(SDDCISSize), ClosestDays, PSEUDO_TUMOURID)
 

#After order the above table by cancer severity then we get rid of duplicate cancers by episode 
table4sub <-  table4sub[!duplicated(table4sub$EPISODEIDLink),]

#Since screened tumor might return nothing if there were no screens tied to a patient with a cancer then we default screened tumor to zero here if if it missing
table4sub$ScreenedTumor[is.na(table4sub$ScreenedTumor)] = 0

#Matching the tumor characteristics to their closest EPISODEID here
   table2$EPISODEIDLink = table4sub$EPISODEIDLink[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
    table2$ClosestDays = table4sub$ClosestDays[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
      table2$ScreenedTumor = table4sub$ScreenedTumor[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
            table2$Type = table4sub$Type[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
               table2$MaxScreened = table4sub$MaxScreened[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
      

    #cleanup
   rm(table4, table4sub)



#This cancer2 variable tags all screens 0 or 1 for whether an Invasive cancer was found or not  
table2$Cancer2 <- ifelse(table2$Cancer == 1 & table2$ScreenedTumor == 1 & table2$Type == "Invasive" & !is.na(table2$Type), 1, 0)
       
  


#This part gets rid of cancers that occur after non attended invite but within time of screening, that is, if the interval cancer was detected around 3 years and 2 months after the previous screening date but they were scheduled for another screening appointment 3 years after their last screening and did not attend we didn't count these as "interval cancers", this daysnext file has information about the times between screened screenings and screening invites that can be used for this, the calculation for this file can be found in the FrankenCode file
daysnext   <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\daysbetweeninvite2.fst")


 #This matches the needed data to table 2
table2$NextInviteDays = daysnext$NextInviteDays[match(table2$EPISODEID, daysnext$EPISODEID)]
table2$PreviousInviteDays = daysnext$PreviousInviteDays[match(table2$EPISODEID, daysnext$EPISODEID)]


#Change next invite days to numerical
table2$NextInviteDays <- as.numeric(table2$NextInviteDays)


# #If the number of days to next invite was less than the number of days the cancer was to the closest screened episode then it is not an interval cancer (it was an unscreened cancer than occurred after an unintended invite), this is our main interval cancer definition

table2$IntervalCancer <- ifelse(
  table2$Cancer == 1,  # if cancer was screen-detected (from table2), not interval
  0,
  ifelse(
    table2$ScreenedTumor == 0 &  # must be a cancer from table4, not screen-detected
    table2$ClosestDays < 1278 & 
    (is.na(table2$NextInviteDays) | table2$ClosestDays < table2$NextInviteDays),
    1, 0
  )
)

#Defaults missing to be 0 for interval cancer
table2$IntervalCancer[is.na(table2$IntervalCancer)] = 0


#This is a similar code but for interval cancers that are only within 1 year
table2$IntervalCancer1Y <- ifelse(
  table2$Cancer == 1,  # if cancer was screen-detected (from table2), not interval
  0,
  ifelse(
    table2$ScreenedTumor == 0 &  # must be a cancer from table4, not screen-detected
    table2$ClosestDays < 366 & 
    (is.na(table2$NextInviteDays) | table2$ClosestDays < table2$NextInviteDays),
    1, 0
  )
)
table2$IntervalCancer1Y[is.na(table2$IntervalCancer1Y)] = 0

#Similar code but now interval cancers within 2 years
table2$IntervalCancer2Y <- ifelse(
  table2$Cancer == 1,  # if cancer was screen-detected (from table2), not interval
  0,
  ifelse(
    table2$ScreenedTumor == 0 &  # must be a cancer from table4, not screen-detected
    table2$ClosestDays < 730 & 
    (is.na(table2$NextInviteDays) | table2$ClosestDays < table2$NextInviteDays),
    1, 0
  )
)

table2$IntervalCancer2Y[is.na(table2$IntervalCancer2Y)] = 0



#Also need to get the episode ids (previous one and next one) in the sequence for later looking at cancer at next screen
  table2$PreviousInviteID = daysnext$PreviousInviteID[match(table2$EPISODEID, daysnext$EPISODEID)]
    table2$NextInviteID = daysnext$NextInviteID[match(table2$EPISODEID, daysnext$EPISODEID)]

rm(daysnext)
rm(daysnextall)

#Creating a word based variable for nicer tables
table2$CancerCat <- ifelse(table2$Cancer == 1, "Cancer Detected", "No Cancer Detected or Not Recalled")
table2$RecallCat <- ifelse(table2$Recall == 1, "Recalled", "No Recall")
table2$FalsePositiveRecallCat <- ifelse(table2$FalsePositiveRecall == 1, "FP Recall", "Not a FP Recall")
table2$CancerCat2 <- ifelse(table2$Cancer2 == 1, "Invasive Cancer Detected", "No Cancer Invasive Detected or Not Recalled")


#Need to create a back up of table 2 to create information on if there was cancer detected at next screen
table2bu <- table2


#Links next episode cancer outcomes to previous episode 
table2$NextCancerCat = table2bu$CancerCat[match(table2$EPISODEID, table2bu$PreviousInviteID)]
table2$NextCancer = table2bu$Cancer[match(table2$EPISODEID, table2bu$PreviousInviteID)]
table2$NextCancer <- ifelse(table2$NextCancer == 1 & table2$NextInviteDays < 1278, table2$NextCancer, 0)
table2$NextCancerType = table2bu$Type[match(table2$EPISODEID, table2bu$PreviousInviteID)]
table2$NextCancerType <- ifelse(table2$NextCancer == 1 & table2$NextInviteDays < 1278, table2$NextCancerType, NA)

#clean up
rm(table2bu)



       
#Calculate new screen types here, basically a column that looks at the type of cancers if they are a screened cancer and another variable that looks at the types of cancers if they are interval
table2$ScreenedType <- ifelse(table2$CancerCat == "Cancer Detected" & table2$ScreenedTumor == 1, table2$Type, NA)
table2$IntervalType <- ifelse(table2$IntervalCancer == 1, table2$Type, NA)

 
#This dataset was based on code that identified the point in time a centre when the rolling percent of two readers was 50% over either two months, four months, or 1 year rolling proportion. Then the dates corresponding for that was noted. This allowed us to get time points for centres (which had timepoints with 50% 2 reader times) where the center first transitioned in order to better compare one and two readers with less time variation, the code for this file can be found in the FrankenCode file
linkdata  <- read.csv("C:\\Users\\u4111872\\Downloads\\UGH\\Centre1vs2TimeData.csv")

 #Goal below is to make linkdata long form so it filters better than rbind with a centre list that is just start of 1994 and end of 1999, then this will add other date ranges for that centre (so centre ID will have the dates corresponding to 4 different date ranges, 1994-1999, year around transition, 4 months around transition, 2 months around transition), the tag variable is a tag to make sure the date range has at least 50% to get rid of centres that transition too early to two readers to have a time period where the first instance of two readers being over 50% wasn't around 50% but could have been 60% or something like that

#This gets out only the variables of interest
 linkdatalabel <- linkdata %>% dplyr::select(OfficeID, DateMin365, DateMax365, DateMin120, DateMax120, DateMin60, DateMax60, Tag60, Tag120, Tag365)

  
#Link the above information with table 2 
table2$DateMin365 = linkdatalabel$DateMin365[match(table2$OfficeID, linkdatalabel$OfficeID)] 
table2$DateMax365 = linkdatalabel$DateMax365[match(table2$OfficeID, linkdatalabel$OfficeID)] 
table2$DateMin120 = linkdatalabel$DateMin120[match(table2$OfficeID, linkdatalabel$OfficeID)] 
table2$DateMax120 = linkdatalabel$DateMax120[match(table2$OfficeID, linkdatalabel$OfficeID)] 
table2$DateMin60 = linkdatalabel$DateMin60[match(table2$OfficeID, linkdatalabel$OfficeID)] 
table2$DateMax60 = linkdatalabel$DateMax60[match(table2$OfficeID, linkdatalabel$OfficeID)] 
table2$Tag60 = linkdatalabel$Tag60[match(table2$OfficeID, linkdatalabel$OfficeID)] 
table2$Tag120 = linkdatalabel$Tag120[match(table2$OfficeID, linkdatalabel$OfficeID)] 
table2$Tag365 = linkdatalabel$Tag365[match(table2$OfficeID, linkdatalabel$OfficeID)] 
 
 
        
```


```{r FilmReader Info, out.width='100%', results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}

#Reads in extra reader data needed 
readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedC.fst"
 creadlist <- c("EPISODEID",  "ReaderNum4", "FILMREADER1", "FILMREADER1RECACTION",
 "FILMREADER2",  "FILMREADER2RECACTION", "F1Cat2", "F2Cat2")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

 #matches to main table
    table2$ReaderNum4 = table2a$ReaderNum4[match(table2$EPISODEID, table2a$EPISODEID)]
    table2$FILMREADER1 = table2a$FILMREADER1[match(table2$EPISODEID, table2a$EPISODEID)]
   table2$FILMREADER1RECACTION = table2a$FILMREADER1RECACTION[match(table2$EPISODEID, table2a$EPISODEID)]
    table2$FILMREADER2 = table2a$FILMREADER2[match(table2$EPISODEID, table2a$EPISODEID)]
  table2$FILMREADER2RECACTION = table2a$FILMREADER2RECACTION[match(table2$EPISODEID, table2a$EPISODEID)]
    table2$F1Cat2 = table2a$F1Cat2[match(table2$EPISODEID, table2a$EPISODEID)]
    table2$F2Cat2 = table2a$F2Cat2[match(table2$EPISODEID, table2a$EPISODEID)]
 rm(table2a)
 
 #This creates a variable that says if the filmreader was a valid read meaning that the ID corresponded to an individual reader id rather than a tag corresponding to more general film reader categories or no film reader data at all, it does this for 1st and 2nd film reader 
 table2$F1Valid <- data.table::fifelse(table2$FILMREADER1 == "", "Missing",
                                      data.table::fifelse(table2$FILMREADER1 %in% nameless | table2$FILMREADER1 %in% conlist, "Invalid", "Valid"))
 
 table2$F2Valid <- data.table::fifelse(table2$FILMREADER2 == "", "Missing",
                                      data.table::fifelse(table2$FILMREADER2 %in% nameless | table2$FILMREADER2 %in% conlist, "Invalid", "Valid"))
 
#Creates another valid column that checks for if there is a reader action listed and if the reader number is valid
 table2$F1Valid2 <- ifelse(!is.na(table2$F1Cat2) & table2$F1Valid == "Valid", 0, 
                           ifelse(is.na(table2$F1Cat2), 0, 1))
  table2$F2Valid2 <- ifelse(!is.na(table2$F2Cat2) & table2$F2Valid == "Valid", 0, 
                           ifelse(is.na(table2$F2Cat2), 0, 1))
  
  #Tags episodes as 1 if both readers (or the one reader) are not valid or there are missing actions for a film reader
  table2$F1F2Valid <- ifelse( table2$F1Valid2 == 1 | table2$F2Valid2 == 1  , 0, 1)
  


#This creates a variable to make year a factor for easier graphing by year or for creating tables by year
  table2$YearFactor <- as.character(table2$Year)
  

#This table looks at percentage of valid film reader screens by year, this was used to check things over but this data is not in the draft
# print("Year by Reader ID validity Table")
# table2 %>% dplyr::select(F1F2Valid, YearFactor) %>% tbl_summary(by = F1F2Valid,  percent = "row")


#Downsizing table2 to make it more manageable, we really just need F1F2Valid later
table2$FILMREADER1RECACTION <- NULL
table2$FILMREADER2RECACTION <- NULL

table2$F1Valid <- NULL
table2$F1Valid2 <- NULL

table2$F2Valid <- NULL
table2$F2Valid2 <- NULL

table2$YearFactor <-NULL






```



```{r allsubsets, out.width='100%', results = "asis", eval = FALSE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}

#This is the code that creates a file of episode ids that match each of the different subset conditions to better be able to run these analyses in a loop, this does not need to be ran if this file already exists 


#This gets all screenings from 1994-1999 and then adds a label to classify them as the "years" subset
SubsetList  <- table2 %>% filter(Year >1993 & Year < 2000) %>% dplyr::select(EPISODEID)
SubsetList$Subset <- "Years"


#This filters to episodes where the centre does have a qualifying 1 year time period around the transition point and then filters to those episode ids, this subset is called "year"
subtable <- table2 %>% filter(dateoffirstofferedappointmentcalc <= DateMax365 & dateoffirstofferedappointmentcalc > DateMin365 & Tag365 == 0) %>% dplyr::select(EPISODEID)
subtable$Subset <- "Year"

#This appends the list
SubsetList <- rbind(SubsetList, subtable)
rm(subtable)


#This gets all screenings from 1997-2005 and then adds a label to classify them as the "years0T" subset as these are the years with 0 tracing issues but with at least some one reader screens 
subtable  <- table2 %>% filter(Year >1996 & Year < 2006) %>% dplyr::select(EPISODEID)
subtable$Subset <- "Years0T"


#This appends the list
SubsetList <- rbind(SubsetList, subtable)
rm(subtable)



#We identified 7 centres that had very clean and sharp transition from 1 to 2 reader (the rest of the centres could have been gradual allowing for points of time where both two readers and one readers were in play or they could have switched to two reader then back to one reader then back to two reader at time points), this is the list of those centres, process for identifying these centres can be seen in the FrankenCode, these centres are no longer looked at and aren't in the draft
officelistcrap <- c("S009", "S011", "S018", "S029", "S054", "S067", "S073")

#Filter much the same as above but only with the centres with sharp transition times
subtable <- table2 %>% filter(dateoffirstofferedappointmentcalc <= DateMax365 & dateoffirstofferedappointmentcalc > DateMin365 & Tag365 == 0 & OfficeID %in% officelistcrap) %>% dplyr::select(EPISODEID)
subtable$Subset <- "Year ST Centres"

#Binds the list
SubsetList <- rbind(SubsetList, subtable)
rm(subtable)



#Does much the same but for 4 months transition period 
subtable <- table2 %>% filter(dateoffirstofferedappointmentcalc <= DateMax120 & dateoffirstofferedappointmentcalc > DateMin120 & Tag120 == 0) %>% dplyr::select(EPISODEID)
subtable$Subset <- "Four"

SubsetList <- rbind(SubsetList, subtable)
rm(subtable)


#2 months transition period focus
subtable <- table2 %>% filter(dateoffirstofferedappointmentcalc <= DateMax60 & dateoffirstofferedappointmentcalc > DateMin60 & Tag60 == 0) %>% dplyr::select(EPISODEID)
subtable$Subset <- "Two"

SubsetList <- rbind(SubsetList, subtable)
rm(subtable)


#THE BELOW WAS A REALLY COMPLICATED CENTRE GROUPING TECHNIQUE THAT DIDN'T MAKE IT INTO THE FINAL DRAFT SO IGNORE

#This gets screenings that have a year transition period as we also want to try and find screenings where film readers had some experience reading as both one and two readers, a lot of times when centres change to two readers they hire new readers so comparing one and two readers means that the film readers in the two reader screens are possibly newer (this is why we control for reader experience in our model), this is just another way of doing that but we don't really use this anymore as the results were the same as our other sensitivity analyses and we are controlling for reader experience anyway
        table2sub <- table2 %>% filter(dateoffirstofferedappointmentcalc <= DateMax365 & dateoffirstofferedappointmentcalc > DateMin365)
        



#Exclude screens without valid film readers and if first rolling mean was greater than 50%
                table2sub <- table2sub %>% filter(F1F2Valid == 1 & Tag365 == 0)



#Here the goal is to take out individual film readers and get prop 1 reader screens, if this is greater than .8 then exclude those readers, for the analysis we did one where screens where both readers needed to have at least some screens reading as one and another where there were only excluded if both readers didn't (so one reader could be excluded but the other reader included then the screen is still included)
        
#These are reader proportion calculations for film reader 1 (R1) and for 2 (R2)
R1 <- table2sub %>% dplyr::select(FILMREADER1, Group)   
R1$FILMREADER <- R1$FILMREADER1
R1$FILMREADER1 <- NULL
R2 <- table2sub %>% dplyr::select(FILMREADER2, Group)   
R2$FILMREADER <- R2$FILMREADER2
R2$FILMREADER2 <- NULL

#Creates a list of all film readers
RListProp <- rbind(R1, R2)

#Calculates proportions
RListProp <- as.data.frame(prop.table(table(RListProp$Group, RListProp$FILMREADER), margin = 2))
RListProp <- RListProp %>% filter(Var1 == "One reader")
RListProp$FILMREADER <- RListProp$Var2
RListProp$OneReaderProp <- RListProp$Freq
RListProp <- RListProp %>% dplyr::select(FILMREADER, OneReaderProp)

#Creates a reader list with filmreaders (both 1 and 2 in same column)
RListFreq <- rbind(R1, R2)
#Calculates how often that reader appears to get frequency
RListFreq <- as.data.frame(table(RListFreq$FILMREADER))
RListFreq$FILMREADER <- RListFreq$Var1
RListFreq <- RListFreq %>% dplyr::select(FILMREADER, Freq)

#Bind total frequency to proportion table and filters out any rows with no film reader number
  RListProp$Freq = RListFreq$Freq[match(RListProp$FILMREADER, RListFreq$FILMREADER)]
  RListProp <- RListProp %>% filter(FILMREADER != "")

#Creates a tag that excludes readers who basically only read as one or two
  RListProp$Exclude <- ifelse(RListProp$OneReaderProp < .20 | RListProp$OneReaderProp > .80, 1, 0)
  
  
   #Creates another table with all filmreaders
  R1 <- table2sub %>% dplyr::select(FILMREADER1, dateoffirstofferedappointmentcalc)   
R1$FILMREADER <- R1$FILMREADER1
R1$FILMREADER1 <- NULL
R2 <- table2sub %>% dplyr::select(FILMREADER2, dateoffirstofferedappointmentcalc)   
R2$FILMREADER <- R2$FILMREADER2
R2$FILMREADER2 <- NULL
RListDates <- rbind(R1, R2)

#This gets the min and max dates for readers  
  ReaderDates  <- setDT(RListDates)[, .(  MinDate = min(dateoffirstofferedappointmentcalc),  MaxDate = max(dateoffirstofferedappointmentcalc) ), by = .(FILMREADER)]
    ReaderDates <- ReaderDates %>% filter(FILMREADER != "")
    
#Looks at how many days they read (adding 1 to minimum date so even if they read for one day it would could as 1 day instead of 0)
    ReaderDates$ReadingDays <- ReaderDates$MaxDate - ReaderDates$MinDate +1

    #Match the number of reading days to the main reade rlist    
RListProp$ReadingDays = ReaderDates$ReadingDays[match(RListProp$FILMREADER, ReaderDates$FILMREADER)]
               
               
     
     #Need to match RListProp Exclude to the 2 film readers
      table2sub$FILMREADER1Exclude = RListProp$Exclude[match(table2sub$FILMREADER1, RListProp$FILMREADER)]
        table2sub$FILMREADER2Exclude = RListProp$Exclude[match(table2sub$FILMREADER2, RListProp$FILMREADER)]
        
        #Creates a tag where the screen is excluded if either reader is excluder
        table2sub$FILMREADERExcludeBoth <- ifelse(table2sub$FILMREADER1Exclude == 1 & table2sub$Group == "One reader", 1,                                                                                                    ifelse(table2sub$FILMREADER1Exclude == 1 | table2sub$FILMREADER2Exclude == 1, 1, 0))
        table2sub$FILMREADERExcludeBoth[is.na(table2sub$FILMREADERExcludeBoth)] <- 0
        
        
        #Another tag where it only excludes screens if both readers would meet exclusion criteria
                table2sub$FILMREADERExcludeOne <-  ifelse(table2sub$FILMREADER1Exclude == 1 & table2sub$Group == "One reader", 1,                                                                                                  ifelse(table2sub$FILMREADER1Exclude == 1 & table2sub$FILMREADER2Exclude == 1, 1,   0))  
                
                table2sub$FILMREADERExcludeOne[is.na(table2sub$FILMREADERExcludeOne)] <- 0
        
       
                
                
        #This is just a table to observe how many exclusions there are by film reader grouping
                table2sub %>% dplyr::select(Group, Cancer, Recall, FILMREADERExcludeBoth, FILMREADERExcludeOne) %>% tbl_summary( by = Group)  %>%
  modify_caption("**365 data from centres where first rollingmean was at less than or equal to .5 and valid reader**")
                
                
      #Creates a group number variable          
      table2sub$GroupNum <- ifelse(table2sub$Group == "More than one reader", 1, 0)
                               
 
     #exclude those screens but allows screens if only1 out of 2 readers would have been excluded (definition 1)
        table2sub1 <-table2sub %>% filter(FILMREADERExcludeOne == 0)
        

               
               
               #Centre propotion levels by centre, so as well as excluding screens with readers who may have read too much as 1 and 2 reader exclusively we also filtered out centres that overall had very mismatched 1 to 2 reader screens 
               table2suboffice  <- setDT(table2sub1)[, .( .N, GroupProp = mean(GroupNum, na.rm = TRUE)), by = .(OfficeID)] 

#Creates office exclude tag               
table2suboffice$OfficeTagIncludeOne <- ifelse(table2suboffice$GroupProp < .1 | table2suboffice$GroupProp > .9, 0, 1)

#Matches that to film reader exclude tag
      table2sub1$OfficeTagIncludeOne = table2suboffice$OfficeTagIncludeOne[match(table2sub1$OfficeID, table2suboffice$OfficeID)]

      #Another descriptive table checking this over before and after removing centers
               table2sub1 %>% dplyr::select(Group, Cancer, Recall, OfficeTagIncludeOne) %>% tbl_summary( by = Group)  %>%
  modify_caption("**365 data from centres where first rollingmean was at less than or equal to .5 and valid reader and where at least one readers have between 20-80% one or two reader screens**")
               
               
               table2sub1 <- table2sub1 %>% filter(OfficeTagIncludeOne == 1)
              
                table2sub1 %>% dplyr::select(Group, Cancer, Recall, OfficeTagIncludeOne) %>% tbl_summary( by = Group)  %>%
  modify_caption("**365 data from centres where first rollingmean was at less than or equal to .5 and valid reader and where at least one readers have between 20-80% one or two reader screens**")
               
             
                #Now this code does the same thing but when excluding two reader screens unless BOTH had enough read as one and two reader 
                 table2sub2 <-table2sub %>% filter(FILMREADERExcludeBoth == 0)
        

               
               
               #Centre propotion levels
               table2suboffice  <- setDT(table2sub2)[, .( .N, GroupProp = mean(GroupNum, na.rm = TRUE)), by = .(OfficeID)] 

table2suboffice$OfficeTagIncludeBoth <- ifelse(table2suboffice$GroupProp < .1 | table2suboffice$GroupProp > .9, 0, 1)


      table2sub2$OfficeTagIncludeBoth = table2suboffice$OfficeTagIncludeBoth[match(table2sub2$OfficeID, table2suboffice$OfficeID)]

               table2sub2 %>% dplyr::select(Group, Cancer, Recall, OfficeTagIncludeBoth) %>% tbl_summary( by = Group)  %>%
  modify_caption("**365 data from centres where first rollingmean was at less than or equal to .5 and valid reader and where both readers have between 20-80% one or two reader screens**")
               
               
                              table2sub2 <- table2sub2 %>% filter(OfficeTagIncludeBoth == 1)
                              
                                   table2sub2 %>% dplyr::select(Group, Cancer, Recall, OfficeTagIncludeBoth) %>% tbl_summary( by = Group)  %>%
  modify_caption("**365 data from centres where first rollingmean was at less than or equal to .5 and valid reader and where both readers have between 20-80% one or two reader screens**")
                                   
                                   
 
              #  Finally, I get the episode ID lists from the two exclusions and add them into the overall subset list                
                                   #Create csv lists here
                                table2sub1 <- table2sub1 %>% dplyr::select(EPISODEID)   
                                table2sub1$Subset <- "2080 Exclude 1"
                                table2sub2 <- table2sub2 %>%  dplyr::select(EPISODEID) 
                                table2sub2$Subset <- "2080 Exclude 2"
                                
                                  SubsetList <- rbind(SubsetList, table2sub1)
                                SubsetList <- rbind(SubsetList, table2sub2)
                                
                                
                                #Out put the subset list as a csv so I don't have to rerun this code everything
                                write.csv(SubsetList, "SubsetList.csv")
                           
                                
                                     
                          #Clean up      
                           rm(table2sub)
                         rm(table2sub1)
                         rm(table2sub2)
                         rm(table2suboffice)
                         rm(R1)
                         rm(R2)
                         rm(RListDates)
                         rm(ReaderDates)
                         rm(RListProp)
                         invisible(gc())
                         
   
                         
#Check if new and old subset file is the same if rerunning code and it shouldn't change
# SubsetListNew <- read.csv("SubsetList.csv")
# SubsetListNew <- SubsetListNew %>% filter(Subset !="Years0T")
# SubsetListOrg <- read.csv("SubsetList BU 13 2 2025.csv")
#   
# 
# SubsetListNew$X <- NULL
# SubsetListOrg$X <- NULL
# 
# identical(SubsetListNew,SubsetListOrg)                       
#                          

        
```



```{r UniqueReadersInfo, out.width='100%', results = "asis", echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE, fig.align="center"}

#This gets the unique number of filmreaders for the 1994-1999 years

#Need to create long form with filmreader id, centre id, and year, start by reading in needed information, I think this was already read in before but this code had a lot of things turning on and off again so you might see code repeating that didn't need to
  readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedC.fst"
 creadlist <- c("EPISODEID",  "ReaderNum4", "FILMREADER1", "F1Cat2", "FILMREADER2", "F2Cat2")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2$ReaderNum4 = table2a$ReaderNum4[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$FILMREADER1 = table2a$FILMREADER1[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$F1Cat2 = table2a$F1Cat2[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$FILMREADER2 = table2a$FILMREADER2[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$F2Cat2 = table2a$F2Cat2[match(table2$EPISODEID, table2a$EPISODEID)]
 rm(table2a)
 
    
 #This recalljoinedpairs data has data on the number of reads a reader has previously read and this is used for the reader experience variable later
  readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2recalljoinedpairs.fst"
 creadlist <- c("EPISODEID",  "RecallAllCountF1", "RecallAllCountF2")
 table2a <- read.fst(readlink, from = fromnum, to = tonum, columns = creadlist)
 

 

      table2$ReaderExp1 = table2a$RecallAllCountF1[match(table2$EPISODEID, table2a$EPISODEID)]
      table2$ReaderExp2 = table2a$RecallAllCountF2[match(table2$EPISODEID, table2a$EPISODEID)]
      

         
 rm(table2a)
 
 #Filters to only screened episodes between 1994-1999
 table2years <- table2 %>% filter(Year > 1993 & Year < 2000 & Screened == 1)

#To get numebr of unique readers we need to stak filmreader 1 and filmreader 2 which were the two primary filmreader fields
table2filmreaderlonga <- table2years %>% dplyr::select(OfficeID, Year, FILMREADER1) %>% filter(!is.na(FILMREADER1) & FILMREADER1 != "")
table2filmreaderlonga$FILMREADER <- table2filmreaderlonga$FILMREADER1
table2filmreaderlonga$FILMREADER1 <- NULL

table2filmreaderlongb <- table2years %>% dplyr::select(OfficeID, Year, FILMREADER2) %>% filter(!is.na(FILMREADER2) & FILMREADER2 != "")
table2filmreaderlongb$FILMREADER <- table2filmreaderlongb$FILMREADER2
table2filmreaderlongb$FILMREADER2 <- NULL

table2filmreaderlong <- rbind(table2filmreaderlonga, table2filmreaderlongb)


#filter out nameless readers
table2filmreaderlong <- table2filmreaderlong %>% filter(FILMREADER %notin% nameless & FILMREADER %notin% conlist)


#Get an median reader experience value and number of unique readers in 1994-1999 time period, I don't think we ended up reporting median experience of readers within 1994-1999 and we just use screening level data for reader experience instead, this does a similar thing where variables needed are taken out by filmreader 1 and 2 and then that data is stacked 
table2filmreaderexp1 <- table2years %>% dplyr::select(EPISODEID, OfficeID, datetakencalc, Group, ScreenType, FILMREADER1, ReaderExp1) %>% filter(!is.na(FILMREADER1) & FILMREADER1 != "")
table2filmreaderexp1$FILMREADER <- table2filmreaderexp1$FILMREADER1
table2filmreaderexp1$FILMREADER1 <- NULL

table2filmreaderexp1$ReaderExp <- table2filmreaderexp1$ReaderExp1
table2filmreaderexp1$ReaderExp1 <- NULL


table2filmreaderexp2 <- table2years %>% dplyr::select(EPISODEID, OfficeID, datetakencalc, Group, ScreenType, FILMREADER2, ReaderExp2) %>% filter(!is.na(FILMREADER2) & FILMREADER2 != "")
table2filmreaderexp2$FILMREADER <- table2filmreaderexp2$FILMREADER2
table2filmreaderexp2$FILMREADER2 <- NULL

table2filmreaderexp2$ReaderExp <- table2filmreaderexp2$ReaderExp2
table2filmreaderexp2$ReaderExp2 <- NULL

table2filmreaderexp <- rbind(table2filmreaderexp1, table2filmreaderexp2)


#Want to exclude 
table2filmreaderexp <- table2filmreaderexp %>% filter(FILMREADER %notin% nameless & FILMREADER %notin% conlist & FILMREADER != "")

print("This number is the number of unique film readers from 1994-1999")
length(unique(table2filmreaderexp$FILMREADER))


#cleaning up all these tables
rm(table2filmreaderlong, table2filmreaderlonga, table2filmreaderlongb, table2filmreaderexp, table2filmreaderexp2, table2filmreaderexp1)


```

```{r PatientLevelTable, out.width='100%', results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}


#Getting needed variales from table 0 which is the patient level table
creadlist <- c("PATIENTID",  "INVALIDNHSNUMBER", "IMDQUINTILE")
table0 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\Table0.fst", columns = creadlist)


#Add labels to table 0
table0$INVALIDNHSNUMBER <- factor(table0$INVALIDNHSNUMBER,
levels = c(0,2,3),
labels = c("Valid # from NBSS", "Valid # from Tracing", "Invalid #"))

#Changing blank data in IMD to NA
 table0$IMDQUINTILE <- as.character(table0$IMDQUINTILE)
table0$IMDQUINTILE[table0$IMDQUINTILE==""] <- NA
table0$IMDQUINTILE <- as.factor(table0$IMDQUINTILE)

#Matching info from table 0 to table 2
 table2$IMDQUINTILE = table0$IMDQUINTILE[match(table2$PATIENTID, table0$PATIENTID)]
  table2$INVALIDNHSNUMBER = table0$INVALIDNHSNUMBER[match(table2$PATIENTID, table0$PATIENTID)]
  

 
 
 #Want to do a patient level table but only patients who had a screening in 1994-1999
 
  #This gets all screens pre 2000
 table299 <- table2 %>% filter(Year < 2000)
 
 
 #This gets patient summary data for screens before 2000 by woman getting their latest data or summing it
 invitessummary <- setDT(table299)[, .(.N, ScreenedCount = sum(Screened), AttendedCount = sum(Attender3), FirstAgeInvite = max(AgeCalc), LastAgeInvite= max(AgeCalc), LastInviteDate = max(dateoffirstofferedappointmentcalc),  Centrecountinvite = length(unique(OfficeID))), by = .(PATIENTID)]
 
 #This then filters screens to be from 1994 onward (so now data is 1994-1999 screens)
  table299 <- table299 %>% filter(Year > 1993)
 

 #This now counts how many screenings and invites a person had within 1994-1999
 invitessummary2 <- setDT(table299)[, .(.N, ScreenedCount = sum(Screened), AttendedCount = sum(Attender3)), by = .(PATIENTID)]
 
 #This filters to just screened screenings
 table299 <- table299 %>% filter(Screened == 1)
 
 #This looks at how many unique centres each patient was screened at from 1994-1999
  screensummary <- setDT(table299)[, .(.N, Centrecountscreen = length(unique(OfficeID))), by = .(PATIENTID)]
  

#This joins information to table 2
  table2$FirstAgeInvite = invitessummary$FirstAgeInvite[match(table2$PATIENTID, invitessummary$PATIENTID)]
  table2$LastAgeInvite = invitessummary$LastAgeInvite[match(table2$PATIENTID, invitessummary$PATIENTID)]
  table2$Centrecountscreen = screensummary$Centrecountscreen[match(table2$PATIENTID, screensummary$PATIENTID)]
  
    table2$InviteCount = invitessummary2$N[match(table2$PATIENTID, invitessummary2$PATIENTID)]
     table2$AttendedCount = invitessummary2$AttendedCount[match(table2$PATIENTID, invitessummary2$PATIENTID)]
 
 

 
#Then subset table 2 again to be screenings within 1994-1999
  table2TR <- table2 %>% filter(Screened == 1 & Year < 2000 & Year > 1993)
 
  #Add better labels
  var_label(table2) <- list(
  FirstAgeInvite = "Age at 1st invitation",
  LastAgeInvite = "Age of last offered invitation 1994-1999",
  IMDQUINTILE = "IMD Quintile from postcode",
    Centrecountscreen = "Number of centres screened at prior to 2000",
    INVALIDNHSNUMBER = "NHS number quality",
    InviteCount = "Number of invites between 1994-1999",
    AttendedCount = "Number of attended between 1994-1999"
)
 
#Create two datasets, one with one reader screens and one with two reader screens 
 table2r1 <- table2TR %>% filter(Group == "One reader")
  table2r2 <- table2TR %>% filter(Group == "More than one reader")
  
#Then add a tag to see if they had one or two reader screenings within 1994-1999 or if they had both
  table2TR$R1 <- ifelse(table2TR$PATIENTID %in% table2r1$PATIENTID, 1, 0)
    table2TR$R2 <- ifelse(table2TR$PATIENTID %in% table2r2$PATIENTID, 1, 0)
    table2TR$ReaderGroup <- ifelse(table2TR$R1 ==1 & table2TR$R2 == 1, "Both",
                          ifelse(table2TR$R1 ==1, "One reader",    
                             ifelse(table2TR$R2 ==1, "More than one reader",   NA
                                 )))
    

 #want only women with at least one screen in 1994-1997
 table2patientlist <- unique(table2TR$PATIENTID)
 
 #Matches reader group to table 2
   table2$ReaderGroup = table2TR$ReaderGroup[match(table2$PATIENTID, table2TR$PATIENTID)]
 
   #Get the variables of interest for women who had at least one screen between 1994-1999
 table2patientlevel <- table2 %>% filter(PATIENTID %in% table2patientlist) %>% dplyr::select(PATIENTID, ReaderGroup, FirstAgeInvite, LastAgeInvite, IMDQUINTILE, Centrecountscreen, INVALIDNHSNUMBER, InviteCount, AttendedCount)
 
 #Then only keep one row per patient ID
 table2patientlevel <- table2patientlevel[!duplicated(table2patientlevel$PATIENTID),]
 table2patientlevel$PATIENTID <- NULL
 
 #Add some better labels
 table2patientlevel$Centrecountscreen <- ifelse(table2patientlevel$Centrecountscreen == 1, "1",
                                         ifelse(table2patientlevel$Centrecountscreen == 2, "2 or more",   
                                        ifelse(table2patientlevel$Centrecountscreen == 3, "2 or more", 
                                             NA   )))
 
 table2patientlevel$InviteCount <- ifelse(table2patientlevel$InviteCount == 1, "1",
                                         ifelse(table2patientlevel$InviteCount == 2, "2",   
                                        ifelse(table2patientlevel$InviteCount == 3, "3", 
                                        ifelse(table2patientlevel$InviteCount > 3, "4 or more", 
                                             NA   ))))
 
  table2patientlevel$AttendedCount <- ifelse(table2patientlevel$AttendedCount == 1, "1",
                                         ifelse(table2patientlevel$AttendedCount == 2, "2",   
                                        ifelse(table2patientlevel$AttendedCount == 3, "3", 
                                        ifelse(table2patientlevel$AttendedCount > 3, "4 or more", 
                                             NA   ))))
 
 
 
 #Copy over the labels from table 2 since subsetting loses these labels
 table2patientlevel <- copy_labels(from = table2, to = table2patientlevel)
 


 
 
#Create patient level table here 
table2patientlevel %>% 
  tbl_summary(by = ReaderGroup, percent = c("column"), digits = list( all_continuous() ~ RRound, all_categorical() ~ c(0, RRound2))) %>% bold_labels() %>% modify_caption("**Women characteristics for women with at least one screening between 1994-1999**")
 

#clean up
rm(table299)
rm(table2patientlevel)
rm(table2r1)
rm(table2r2)
rm(table2sub)
rm(table2suboffice)
rm(table2TR)
rm(check1)
rm(check2)
rm(checkmatch)
rm(checkmatch2)
rm(checkmatchb)
rm(checkmatchb2)
rm(invitessummary)
rm(invitessummary2)
rm(matchdata)
rm(matchtable)
rm(matchtable2)
rm(matchtableb)
rm(matchtableb2)
rm(R1)
rm(R2)

#This code clears memory to try and prevent crashes 
invisible(gc())

        
```


Screening level tables.

```{r ScreeningPatientLevelTable, out.width='100%', results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}

#This data is data used for calculating recall rate and also contains number of screens previous read by each filmreader at each screen  
  readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2recalljoinedpairs.fst"
 creadlist <- c("EPISODEID",  "RecallByFS500", "RecallAllCountF1", "RecallAllCountF2")
 table2a <- read.fst(readlink, from = fromnum, to = tonum, columns = creadlist)

#This calcualtes the average reader experience per row if there are more than 1 reader at the screen  
table2a <- table2a %>% rowwise() %>% mutate(ReaderExp=mean(c(RecallAllCountF1, RecallAllCountF2), na.rm=T)) 

#Joins information
      table2$ReaderExp = table2a$ReaderExp[match(table2$EPISODEID, table2a$EPISODEID)]
        # table2$ReaderExp <- table2$ReaderExp/10000

 #Clean up        
 rm(table2a)
 

#Nicer labels
 var_label(table2) <- list(
  AgeCalc = "Age",
  ReaderExp = "Reader Experience",
  IMDQUINTILE = "IMD",
  Screened = "Screened",
    ScreenType = "Screen Type",
    Group = "Reader Number",
    RecallCat = "Recalled or not",
    FalsePositiveRecallCat = "False positive recall",
    IntervalCancer = "Interval cancer",
    NextCancerCat = "Cancer at next screen",
  CancerCat = "Cancer detected at screen",
  ScreenedType = "Screen detected cancer type"
)

 
#These tables are in a loop format because there are multiple descriptive tables based on subset, this one is just pulling out the main table however which is just the years subset (1994-1999)
   TimeRange <- c("Years")

   #Loopoing through whatever is in time range
    for(Time in TimeRange){
 
      #This creates a list of episodes that match the certain subset term in the subsetlist that was created earlier
        Epilist <- SubsetList %>% filter(Subset %in% Time)
        
   
 #This first table is only prevalent screenings, this takes out the variables to be in the table then breaks it down by reader group, then decimal formatting is applied as needed to clean up the tables       
screentable1 <- table2 %>% filter(ScreenType == "Prevalent" & EPISODEID %in% Epilist$EPISODEID & Screened == 1) %>%  dplyr::select(Group, AgeCalc, Year, ReaderExp, IMDQUINTILE,  RecallCat, FalsePositiveRecallCat,  CancerCat, CancerCat2, ScreenedType, IntervalCancer,  IntervalCancer1Y, IntervalCancer2Y, NextCancerCat) %>%
  tbl_summary(by = Group, type = list(Year ~ "continuous"),
              digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2), CancerCat ~ c(0, RRound2),
                            IntervalCancer ~ c(0, RRound2),
                            NextCancerCat ~ c(0, RRound2)
                            )) %>%
   bold_labels()

#This is the second table with incident screens
screentable2 <-  table2 %>% filter(ScreenType == "Incident" & EPISODEID %in% Epilist$EPISODEID & Screened == 1) %>%  dplyr::select(Group, AgeCalc, Year, ReaderExp, IMDQUINTILE,  RecallCat, FalsePositiveRecallCat, CancerCat, CancerCat2,  ScreenedType, IntervalCancer,  IntervalCancer1Y, IntervalCancer2Y, NextCancerCat) %>%
  tbl_summary(by = Group, type = list(Year ~ "continuous"),
                   digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2), CancerCat ~ c(0, RRound2),
                            IntervalCancer ~ c(0, RRound2),
                            NextCancerCat ~ c(0, RRound2)
                            )) %>%    bold_labels()

#This prints labels explaining the data subset and which columns are prevalent and incident, then prints the merged tables
print(Time)
print("First two columns are prevalent, last two are incident, can't figure out how to add spanning header")
 print(tbl_merge(
    tbls = list(screentable1, screentable2),
    tab_spanner = c("**Prevalent**", "**Incident**")))
  

    }
   
   
  #This is the extra tables to be ran 
   TimeRange <- c("Years0T", "Year", "Four", "Two", "Year ST Centres", "2080 Exclude 1", "2080 Exclude 2")
   
 
#This was originally appendix numbering but for this draft I am moving things around a lot so not really using the numbering system in code   
 tnum <- 1
 
 #Same loop as above but with the other datasubsets
    for(Time in TimeRange){
 
        Epilist <- SubsetList %>% filter(Subset %in% Time)
        
        
screentable1 <- table2 %>% filter(ScreenType == "Prevalent" & EPISODEID %in% Epilist$EPISODEID & Screened == 1) %>%   dplyr::select(Group, AgeCalc, Year, ReaderExp, IMDQUINTILE,  RecallCat, FalsePositiveRecallCat, CancerCat, CancerCat2,  ScreenedType, IntervalCancer,  IntervalCancer1Y, IntervalCancer2Y, NextCancerCat) %>%
  tbl_summary(by = Group, type = list(Year ~ "continuous"),
                    digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2), CancerCat ~ c(0, RRound2),
                            IntervalCancer ~ c(0, RRound2),
                            NextCancerCat ~ c(0, RRound2)
                            ))  %>%
   bold_labels()

screentable2 <-  table2 %>% filter(ScreenType == "Incident" & EPISODEID %in% Epilist$EPISODEID & Screened == 1) %>%   dplyr::select(Group, AgeCalc, Year, ReaderExp, IMDQUINTILE,  RecallCat, FalsePositiveRecallCat, CancerCat, CancerCat2,  ScreenedType, IntervalCancer, IntervalCancer1Y, IntervalCancer2Y, NextCancerCat) %>%
  tbl_summary(by = Group, type = list(Year ~ "continuous"),
                     digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2), CancerCat ~ c(0, RRound2),
                            IntervalCancer ~ c(0, RRound2),
                            NextCancerCat ~ c(0, RRound2)
                            )) %>%    bold_labels() %>%
  modify_caption(paste0("**Table Screening Outcomes, Subset - ", Time, "**"))





 screentable <- (tbl_merge(
    tbls = list(screentable1, screentable2),
    tab_spanner = c("**Prevalent**", "**Incident**")))
 
 #Here instead of printing the tables here they are saved as an object and printed later in the appendix section 
    invisible(  assign(  paste("screeningoutcometable", tnum, sep = ""), screentable ))
      

       tnum <- tnum +1
  

    }


 
 #FILM READER CHECK
 #This code gets screenings from 1994-1999 and then counts number of unique film readers for count
 
 check <- table2 %>% filter(Year > 1993 & Year < 2000 & Screened == 1)
 
 check1 <- check %>% dplyr::select(FILMREADER1)
 check1$FILMREADER <- check1$FILMREADER1
 check1$FILMREADER1 <- NULL
 
  check2 <- check %>% dplyr::select(FILMREADER2)
 check2$FILMREADER <- check2$FILMREADER2
 check2$FILMREADER2 <- NULL
 
 check3 <- rbind(check1, check2)
 
 check3 <- check3 %>% filter(FILMREADER %notin% nameless & FILMREADER %notin% conlist & FILMREADER != "")
 
 print("Unique film")
 length(unique(check3$FILMREADER))
 


        
```

```{r sensspecppv, out.width='100%', results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}

#This code looks at the overall senstivity and specificity and other related statistics for the screens from 1994-1999



#Create a loop through prevalent and incident
ScreenType <- c("Prevalent", "Incident")


#Empty dataframe for results 
Results <- NULL

#This was a next cancers 2 definition that originally only looked at cancers at next screen if they were invasive, not used anymore but was originally in our 3rd cancer definition
table2$NextCancer2 <- ifelse(table2$NextCancer == 1 & table2$NextCancerType == "Invasive", 1, 0)

#Looping through the cancer diagnoses definitions
CancerDiagList <- c("CancerDiag1", "CancerDiag2", "CancerDiag3")

#Loop

for (CD in CancerDiagList) {
for (ST in ScreenType) {

#Overall and reader 1 and reader 2 datasets, get screens and within certain years 
table2yr0 <- table2 %>% filter(Screened == 1 & ScreenType == ST & Year %in% c("1994", "1995", "1996", "1997", "1998", "1999"))
table2yr1 <- table2 %>% filter(Screened == 1 & Group == "One reader" & ScreenType == ST & Year %in% c("1994", "1995", "1996", "1997", "1998", "1999"))
table2yr2 <- table2 %>% filter(Screened == 1 & Group == "More than one reader" & ScreenType == ST & Year %in% c("1994", "1995", "1996", "1997", "1998", "1999"))

#Cancer Diagnosis defs for each of the three datasets with the first cancer diagnosis being cancer at screen or interval cancer
table2yr0$CancerDiag1 <- ifelse(table2yr0$Cancer == 1 | table2yr0$IntervalCancer == 1, 1, 0)
table2yr1$CancerDiag1 <- ifelse(table2yr1$Cancer == 1 | table2yr1$IntervalCancer == 1, 1, 0)
table2yr2$CancerDiag1 <- ifelse(table2yr2$Cancer == 1 | table2yr2$IntervalCancer == 1, 1, 0)


#Second cancer diagnosis is cancer at screen, interval cancer, or any cancer at next screen
table2yr0$CancerDiag2 <- ifelse(table2yr0$Cancer == 1 | table2yr0$IntervalCancer == 1 | table2yr0$NextCancer == 1, 1, 0)
table2yr1$CancerDiag2 <- ifelse(table2yr1$Cancer == 1 | table2yr1$IntervalCancer == 1 | table2yr1$NextCancer == 1, 1, 0)
table2yr2$CancerDiag2 <- ifelse(table2yr2$Cancer == 1 | table2yr2$IntervalCancer == 1 | table2yr2$NextCancer == 1, 1, 0)


#Third and no longer used cancer diagnosis definition is cancer at screen, interval cancer, and cancer at nest screen but only if it is invasive
table2yr0$CancerDiag3 <- ifelse(table2yr0$Cancer == 1 | table2yr0$IntervalCancer == 1 | table2yr0$NextCancer2 == 1, 1, 0)
table2yr1$CancerDiag3 <- ifelse(table2yr1$Cancer == 1 | table2yr1$IntervalCancer == 1 | table2yr1$NextCancer2 == 1, 1, 0)
table2yr2$CancerDiag3 <- ifelse(table2yr2$Cancer == 1 | table2yr2$IntervalCancer == 1 | table2yr2$NextCancer2 == 1, 1, 0)

#Calculate TP, as you can see here the [[CD]] part is referring to one of the three cancer definitions above
tp0 <- (nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0[[CD]] == 1),]))
tp1 <- (nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1[[CD]] == 1),]))
tp2 <- (nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2[[CD]] == 1),]))

#Calculate FP
fp0 <- (nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0[[CD]] == 0),]))
fp1 <- (nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1[[CD]] == 0),]))
fp2 <- (nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2[[CD]] == 0),]))


#Calculate FN
fn0 <- (nrow(table2yr0[which(table2yr0$Recall==0 & table2yr0[[CD]] == 1),]))
fn1 <- (nrow(table2yr1[which(table2yr1$Recall==0 & table2yr1[[CD]] == 1),]))
fn2 <- (nrow(table2yr2[which(table2yr2$Recall==0 & table2yr2[[CD]] == 1),]))


#Calculate TN
tn0 <- (nrow(table2yr0[which(table2yr0$Recall==0 & table2yr0[[CD]] == 0),]))
tn1 <- (nrow(table2yr1[which(table2yr1$Recall==0 & table2yr1[[CD]] == 0),]))
tn2 <- (nrow(table2yr2[which(table2yr2$Recall==0 & table2yr2[[CD]] == 0),]))

#Labels for fp tn and such
tp0label <- paste0(tp0, " (", RRound((tp0/sum(tp0+fp0+fn0+tn0))*100), "%)")
tp1label <- paste0(tp1, " (", RRound((tp1/sum(tp1+fp1+fn1+tn1))*100), "%)")
tp2label <- paste0(tp2, " (", RRound((tp2/sum(tp2+fp2+fn2+tn2))*100), "%)")

fp0label <- paste0(fp0, " (", RRound((fp0/sum(tp0+fp0+fn0+tn0))*100), "%)")
fp1label <- paste0(fp1, " (", RRound((fp1/sum(tp1+fp1+fn1+tn1))*100), "%)")
fp2label <- paste0(fp2, " (", RRound((fp2/sum(tp2+fp2+fn2+tn2))*100), "%)")

fn0label <- paste0(fn0, " (", RRound((fn0/sum(tp0+fp0+fn0+tn0))*100), "%)")
fn1label <- paste0(fn1, " (", RRound((fn1/sum(tp1+fp1+fn1+tn1))*100), "%)")
fn2label <- paste0(fn2, " (", RRound((fn2/sum(tp2+fp2+fn2+tn2))*100), "%)")

tn0label <- paste0(tn0, " (", RRound((tn0/sum(tp0+fp0+fn0+tn0))*100), "%)")
tn1label <- paste0(tn1, " (", RRound((tn1/sum(tp1+fp1+fn1+tn1))*100), "%)")
tn2label <- paste0(tn2, " (", RRound((tn2/sum(tp2+fp2+fn2+tn2))*100), "%)")



#Calculate sensitivity (screened cancers)/(screened cancers + interval cancers), overall, 1 reader 2 reader
sens0 <- RRound((tp0/(tp0+fn0))*100)
sens1 <- RRound((tp1/(tp1+fn1))*100)
sens2 <- RRound((tp2/(tp2+fn2))*100)

#CIs for sens
sens0UCI <- (binom.confint(x = tp0, n = tp0 + fn0, methods = "exact")$upper)*100
sens0LCI <- (binom.confint(x = tp0, n = tp0 + fn0, methods = "exact")$lower)*100

sens1UCI <- (binom.confint(x = tp1, n = tp1 + fn1, methods = "exact")$upper)*100
sens1LCI <- (binom.confint(x = tp1, n = tp1 + fn1, methods = "exact")$lower)*100

sens2UCI <- (binom.confint(x = tp2, n = tp2 + fn2, methods = "exact")$upper)*100
sens2LCI <- (binom.confint(x = tp2, n = tp2 + fn2, methods = "exact")$lower)*100

#Paste together
sens0label <- paste0(sens0, " (", RRound(sens0LCI), "-", RRound(sens0UCI), ")")
sens1label <- paste0(sens1, " (", RRound(sens1LCI), "-", RRound(sens1UCI), ")")
sens2label <- paste0(sens2, " (", RRound(sens2LCI), "-", RRound(sens2UCI), ")")


#Calculate specificity (no screened cancers or interval cancer)/screened but not recalled  overall, 1 reader 2 reader
spec0 <- RRound((tn0/(tn0+fp0))*100)
spec1 <- RRound((tn1/(tn1+fp1))*100)
spec2 <- RRound((tn2/(tn2+fp2))*100)

#CIs for sens
spec0UCI <- (binom.confint(x = tn0, n = tn0+fp0, methods = "exact")$upper)*100
spec0LCI <- (binom.confint(x = tn0, n = tn0+fp0, methods = "exact")$lower)*100

spec1UCI <- (binom.confint(x = tn1, n = tn1+fp1, methods = "exact")$upper)*100
spec1LCI <- (binom.confint(x = tn1, n = tn1+fp1, methods = "exact")$lower)*100

spec2UCI <- (binom.confint(x = tn2, n = tn2+fp2, methods = "exact")$upper)*100
spec2LCI <- (binom.confint(x = tn2, n = tn2+fp2, methods = "exact")$lower)*100

#Paste together
spec0label <- paste0(spec0, " (", RRound(spec0LCI), "-", RRound(spec0UCI), ")")
spec1label <- paste0(spec1, " (", RRound(spec1LCI), "-", RRound(spec1UCI), ")")
spec2label <- paste0(spec2, " (", RRound(spec2LCI), "-", RRound(spec2UCI), ")")



#Calculate ppv (screened cancers / recalled)  overall, 1 reader 2 reader
ppv0 <- RRound((tp0/(tp0+fp0))*100)
ppv1 <- RRound((tp1/(tp1+fp1))*100)
ppv2 <- RRound((tp2/(tp2+fp2))*100)


#CIs for sens
ppv0UCI <- (binom.confint(x = tp0, n = tp0+fp0, methods = "exact")$upper)*100
ppv0LCI <- (binom.confint(x = tp0, n = tp0+fp0, methods = "exact")$lower)*100

ppv1UCI <- (binom.confint(x = tp1, n = tp1+fp1, methods = "exact")$upper)*100
ppv1LCI <- (binom.confint(x = tp1, n = tp1+fp1, methods = "exact")$lower)*100

ppv2UCI <- (binom.confint(x = tp2, n = tp2+fp2, methods = "exact")$upper)*100
ppv2LCI <- (binom.confint(x = tp2, n = tp2+fp2, methods = "exact")$lower)*100

#Paste together
ppv0label <- paste0(ppv0, " (", RRound(ppv0LCI), "-", RRound(ppv0UCI), ")")
ppv1label <- paste0(ppv1, " (", RRound(ppv1LCI), "-", RRound(ppv1UCI), ")")
ppv2label <- paste0(ppv2, " (", RRound(ppv2LCI), "-", RRound(ppv2UCI), ")")

#Calculate npv (screened cancers / recalled)  overall, 1 reader 2 reader
npv0 <- RRound((tn0/(tn0+fn0))*100)
npv1 <- RRound((tn1/(tn1+fn1))*100)
npv2 <- RRound((tn2/(tn2+fn2))*100)

#CIs for sens
npv0UCI <- (binom.confint(x = tn0, n = tn0+fn0, methods = "exact")$upper)*100
npv0LCI <- (binom.confint(x = tn0, n = tn0+fn0, methods = "exact")$lower)*100

npv1UCI <- (binom.confint(x = tn1, n = tn1+fn1, methods = "exact")$upper)*100
npv1LCI <- (binom.confint(x = tn1, n = tn1+fn1, methods = "exact")$lower)*100

npv2UCI <- (binom.confint(x = tn2, n = tn2+fn2, methods = "exact")$upper)*100
npv2LCI <- (binom.confint(x = tn2, n = tn2+fn2, methods = "exact")$lower)*100

#Paste together
npv0label <- paste0(npv0, " (", RRound(npv0LCI), "-", RRound(npv0UCI), ")")
npv1label <- paste0(npv1, " (", RRound(npv1LCI), "-", RRound(npv1UCI), ")")
npv2label <- paste0(npv2, " (", RRound(npv2LCI), "-", RRound(npv2UCI), ")")



#Create rows and columns for the dataset
Statistics <- c("TP", "FP", "TN", "FN", "Sensitivity", "Specificity", "PPV", "NPV")
Overall <- c(tp0label, fp0label, tn0label, fn0label, sens0label, spec0label, ppv0label, npv0label)
OneReader <- c(tp1label, fp1label, tn1label, fn1label, sens1label, spec1label, ppv1label, npv1label)
TwoReader <- c(tp2label, fp2label, tn2label, fn2label, sens2label, spec2label, ppv2label, npv2label)

#Create dataset
Results1 <- data.frame(Statistics, Overall,OneReader,TwoReader)

#Add label saying what screentype it is and what cancer diagnosis definition
Results1$ScreenType <- ST
Results1$CancerDiagnosis <- CD

#Append to results
Results <- rbind(Results, Results1)

}}


#Then format tables a bit more to join the prevalent and incident together (so only need to look through cancer diagnoses definitions)
for (CD in CancerDiagList) {

#Trying to get data from long to wide, basically getting the prevalent and the incident to be side to side in the table
ResultsP <- Results %>% filter(ScreenType == "Prevalent" & CancerDiagnosis == CD)
ResultsP$ScreenType <- NULL
ResultsI <- Results %>% filter(ScreenType == "Incident" & CancerDiagnosis == CD)
ResultsI$ScreenType <- NULL

ResultsP$'Overall - P' <- ResultsP$Overall
ResultsP$'OneReader - P' <- ResultsP$OneReader
ResultsP$'TwoReader - P' <- ResultsP$TwoReader
ResultsP$Overall <- NULL
ResultsP$OneReader <- NULL
ResultsP$TwoReader <- NULL

ResultsI$'Overall - I' <- ResultsI$Overall
ResultsI$'OneReader - I' <- ResultsI$OneReader
ResultsI$'TwoReader - I' <- ResultsI$TwoReader
ResultsI$Overall <- NULL
ResultsI$OneReader <- NULL
ResultsI$TwoReader <- NULL
ResultsI$CancerDiagnosis <- NULL


#Merge the above on statistics
ResultsAllPrint <- ResultsP %>% right_join(ResultsI, by=c("Statistics"))

#Print the results
    print(kable(ResultsAllPrint
 , caption = paste0("**Table ", tablenum, ": Recall Accuracy by Reader Number", "**") , padding=-1L, row.names = FALSE  ))
       
       tablenum <- tablenum + 1
       
       rm(table2yr1)
       rm(table2yr2)
}






#Getting data for graph, this graph isn't used in the draft


#Make wide to long

  ResultsAllLong <-  melt(Results, id.vars=c("CancerDiagnosis", "Statistics", "ScreenType"))
  
#List of stats wanted and filter on this list
  statslist2 <- c("Sensitivity", "Specificity",  "PPV", "NPV")
  ResultsAllLong <- ResultsAllLong %>% filter(Statistics %in% statslist2 & variable != "Overall")
  
#The dataset originally has number labeling to be present in a table so this is seperating those columns into value, lower ci and upper ci again to be able to be treated as numbers in the graphs
ResultsAllLong <- separate(ResultsAllLong, value, into = c("value", "ci"), sep = " (?=[^ ]+$)")
  
  ResultsAllLong$lower =  as.numeric(sub(".*?(\\d+\\.\\d+).*", "\\1", ResultsAllLong$ci))
  ResultsAllLong$upper =  as.numeric(sub(".*\\b(\\d+\\.\\d+).*", "\\1", ResultsAllLong$ci))
  
  ResultsAllLong$value <- as.numeric(ResultsAllLong$value)
  
ResultsAllLong$variable <- ifelse(ResultsAllLong$variable == "OneReader", "Single reading", "Double reading")

ResultsAllLong$ST <- paste0(ResultsAllLong$CancerDiagnosis, "-", ResultsAllLong$ScreenType)

ResultsAllLong <- ResultsAllLong %>% filter(CancerDiagnosis != "CancerDiag2")
       
       
  
     #Create graph      
      jpeg("C:\\Users\\u4111872\\Downloads\\UGH\\graphs\\OneVTwoDraftGraphNotByYear.png", width = 3700, height = 5200, res=400)
      
  ResultsAllLong %>%
  ggplot( aes(x=as.factor(ST), y=value, group = variable, color = variable)) +
    geom_point() +   theme_minimal()+ 
  geom_errorbar( aes(ymin = lower, ymax = upper)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
#  scale_x_continuous(breaks = outputall$Group.1) +
  scale_color_manual(values = c("#00AFBB", "#E7B800")) +
  theme(legend.position = "bottom") + ggtitle("Statistics over time by reader number") +
  xlab("Year") + ylab("Percent") + facet_wrap(~ Statistics, scales = "free", ncol = 2) 


     
      invisible(dev.off())
      

      


    
        
```



```{r sensspecppv2, out.width='100%', results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}

#This is very similar to the above but we are also looping by year so see if sensitivity and specificity varies by year for one and two reader screens

#Loop lists
YearList <- c(1994, 1995, 1996, 1997, 1998, 1999)
ScreenType <- c("Prevalent", "Incident")



#Creating two different blank datasets, in the above code I only saved the label statistics so had to break those back down into statistics to graph them, there I just create two datasets in the first place, one for table information and one for graphing
ResultsAll <- NULL
ResultsAll2 <- NULL

#loop de loop
for (ST in ScreenType) {
for (YL in YearList) {

#reader 1 and reader 2 datasets
table2yr0 <- table2 %>% filter(Year == YL & ScreenType == ST)
table2yr1 <- table2 %>% filter(Group == "One reader" & Year == YL & ScreenType == ST)
table2yr2 <- table2 %>% filter(Group == "More than one reader" & Year == YL & ScreenType == ST)


#Calculate TP
tp0 <- (nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0$Cancer == 1),]))
tp1 <- (nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1$Cancer == 1),]))
tp2 <- (nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2$Cancer == 1),]))

#Calculate FP
fp0 <- (nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0$Cancer == 0),]))
fp1 <- (nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1$Cancer == 0),]))
fp2 <- (nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2$Cancer == 0),]))


#Calculate FN
fn0 <- (nrow(table2yr0[which(table2yr0$Recall==0 & table2yr0$IntervalCancer == 1),]))
fn1 <- (nrow(table2yr1[which(table2yr1$Recall==0 & table2yr1$IntervalCancer == 1),]))
fn2 <- (nrow(table2yr2[which(table2yr2$Recall==0 & table2yr2$IntervalCancer == 1),]))


#Calculate TN
tn0 <- (nrow(table2yr0[which(table2yr0$Recall==0 & table2yr0$IntervalCancer == 0),]))
tn1 <- (nrow(table2yr1[which(table2yr1$Recall==0 & table2yr1$IntervalCancer == 0),]))
tn2 <- (nrow(table2yr2[which(table2yr2$Recall==0 & table2yr2$IntervalCancer == 0),]))

#Calculate sensitivity (screened cancers)/(screened cancers + interval cancers), overall, 1 reader 2 reader
sens0 <- RRound(((nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0$Cancer == 1),]))/(sum(table2yr0$Cancer) + sum(table2yr0$IntervalCancer)))*100)
sens1 <- RRound(((nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1$Cancer == 1),]))/(sum(table2yr1$Cancer) + sum(table2yr1$IntervalCancer)))*100)
sens2 <- RRound(((nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2$Cancer == 1),]))/(sum(table2yr2$Cancer) + sum(table2yr2$IntervalCancer)))*100)

#CIs for sens
sens0UCI <- (binom.confint(x = (nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0$Cancer == 1),])), n = sum(table2yr0$Cancer) + sum(table2yr0$IntervalCancer), methods = "exact")$upper)*100
sens0LCI <- (binom.confint(x = (nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0$Cancer == 1),])), n = sum(table2yr0$Cancer) + sum(table2yr0$IntervalCancer), methods = "exact")$lower)*100

sens1UCI <- (binom.confint(x = (nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1$Cancer == 1),])), n = sum(table2yr1$Cancer) + sum(table2yr1$IntervalCancer), methods = "exact")$upper)*100
sens1LCI <- (binom.confint(x = (nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1$Cancer == 1),])), n = sum(table2yr1$Cancer) + sum(table2yr1$IntervalCancer), methods = "exact")$lower)*100

sens2UCI <- (binom.confint(x = (nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2$Cancer == 1),])), n = sum(table2yr2$Cancer) + sum(table2yr2$IntervalCancer), methods = "exact")$upper)*100
sens2LCI <- (binom.confint(x = (nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2$Cancer == 1),])), n = sum(table2yr2$Cancer) + sum(table2yr2$IntervalCancer), methods = "exact")$lower)*100

#Paste together
sens0label <- paste0(sens0, " (", RRound(sens0LCI), "-", RRound(sens0UCI), ")")
sens1label <- paste0(sens1, " (", RRound(sens1LCI), "-", RRound(sens1UCI), ")")
sens2label <- paste0(sens2, " (", RRound(sens2LCI), "-", RRound(sens2UCI), ")")


#Calculate specificity (no screened cancers or interval cancer)/screened but not recalled  overall, 1 reader 2 reader
spec0 <- RRound((nrow(table2yr0[which(table2yr0$Screened==1 & table2yr0$Recall==0 & table2yr0$IntervalCancer == 0),])/nrow(table2yr0[which(table2yr0$Screened==1 & table2yr0$Cancer==0 & table2yr0$IntervalCancer == 0),]))*100)
spec1 <- RRound((nrow(table2yr1[which(table2yr1$Screened==1 & table2yr1$Recall==0 & table2yr1$IntervalCancer == 0),])/nrow(table2yr1[which(table2yr1$Screened==1 & table2yr1$Cancer==0 & table2yr1$IntervalCancer == 0),]))*100)
spec2 <- RRound((nrow(table2yr2[which(table2yr2$Screened==1 & table2yr2$Recall==0 & table2yr2$IntervalCancer == 0),])/nrow(table2yr2[which(table2yr2$Screened==1 & table2yr2$Cancer==0 & table2yr2$IntervalCancer == 0),]))*100)

#CIs for sens
spec0UCI <- (binom.confint(x = nrow(table2yr0[which(table2yr0$Screened==1 & table2yr0$Recall==0 & table2yr0$IntervalCancer == 0),]), n = nrow(table2yr0[which(table2yr0$Screened==1 & table2yr0$Cancer==0 & table2yr0$IntervalCancer == 0),]), methods = "exact")$upper)*100
spec0LCI <- (binom.confint(x = nrow(table2yr0[which(table2yr0$Screened==1 & table2yr0$Recall==0 & table2yr0$IntervalCancer == 0),]), n = nrow(table2yr0[which(table2yr0$Screened==1 & table2yr0$Cancer==0 & table2yr0$IntervalCancer == 0),]), methods = "exact")$lower)*100

spec1UCI <- (binom.confint(x = nrow(table2yr1[which(table2yr1$Screened==1 & table2yr1$Recall==0 & table2yr1$IntervalCancer == 0),]), n = nrow(table2yr1[which(table2yr1$Screened==1 & table2yr1$Cancer==0 & table2yr1$IntervalCancer == 0),]), methods = "exact")$upper)*100
spec1LCI <- (binom.confint(x = nrow(table2yr1[which(table2yr1$Screened==1 & table2yr1$Recall==0 & table2yr1$IntervalCancer == 0),]), n = nrow(table2yr1[which(table2yr1$Screened==1 & table2yr1$Cancer==0 & table2yr1$IntervalCancer == 0),]), methods = "exact")$lower)*100

spec2UCI <- (binom.confint(x = nrow(table2yr2[which(table2yr2$Screened==1 & table2yr2$Recall==0 & table2yr2$IntervalCancer == 0),]), n = nrow(table2yr2[which(table2yr2$Screened==1 & table2yr2$Cancer==0 & table2yr2$IntervalCancer == 0),]), methods = "exact")$upper)*100
spec2LCI <- (binom.confint(x = nrow(table2yr2[which(table2yr2$Screened==1 & table2yr2$Recall==0 & table2yr2$IntervalCancer == 0),]), n = nrow(table2yr2[which(table2yr2$Screened==1 & table2yr2$Cancer==0 & table2yr2$IntervalCancer == 0),]), methods = "exact")$lower)*100

#Paste together
spec0label <- paste0(spec0, " (", RRound(spec0LCI), "-", RRound(spec0UCI), ")")
spec1label <- paste0(spec1, " (", RRound(spec1LCI), "-", RRound(spec1UCI), ")")
spec2label <- paste0(spec2, " (", RRound(spec2LCI), "-", RRound(spec2UCI), ")")



#Calculate ppv (screened cancers / recalled)  overall, 1 reader 2 reader
ppv0 <- RRound(((nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0$Cancer == 1),]))/nrow(table2yr0[which(table2yr0$Recall==1),]))*100)
ppv1 <- RRound(((nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1$Cancer == 1),]))/nrow(table2yr1[which(table2yr1$Recall==1),]))*100)
ppv2 <- RRound(((nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2$Cancer == 1),]))/nrow(table2yr2[which(table2yr2$Recall==1),]))*100)

#CIs for sens
ppv0UCI <- (binom.confint(x = (nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0$Cancer == 1),])), n = nrow(table2yr0[which(table2yr0$Recall==1),]), methods = "exact")$upper)*100
ppv0LCI <- (binom.confint(x = (nrow(table2yr0[which(table2yr0$Recall==1 & table2yr0$Cancer == 1),])), n = nrow(table2yr0[which(table2yr0$Recall==1),]), methods = "exact")$lower)*100

ppv1UCI <- (binom.confint(x = (nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1$Cancer == 1),])), n = nrow(table2yr1[which(table2yr1$Recall==1),]), methods = "exact")$upper)*100
ppv1LCI <- (binom.confint(x = (nrow(table2yr1[which(table2yr1$Recall==1 & table2yr1$Cancer == 1),])), n = nrow(table2yr1[which(table2yr1$Recall==1),]), methods = "exact")$lower)*100

ppv2UCI <- (binom.confint(x = (nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2$Cancer == 1),])), n = nrow(table2yr2[which(table2yr2$Recall==1),]), methods = "exact")$upper)*100
ppv2LCI <- (binom.confint(x = (nrow(table2yr2[which(table2yr2$Recall==1 & table2yr2$Cancer == 1),])), n = nrow(table2yr2[which(table2yr2$Recall==1),]), methods = "exact")$lower)*100

#Paste together
ppv0label <- paste0(ppv0, " (", RRound(ppv0LCI), "-", RRound(ppv0UCI), ")")
ppv1label <- paste0(ppv1, " (", RRound(ppv1LCI), "-", RRound(ppv1UCI), ")")
ppv2label <- paste0(ppv2, " (", RRound(ppv2LCI), "-", RRound(ppv2UCI), ")")

#Calculate npv (screened cancers / recalled)  overall, 1 reader 2 reader
npv0 <- RRound(((nrow(table2yr0[which(table2yr0$Recall==0 & table2yr0$IntervalCancer == 0),]))/nrow(table2yr0[which(table2yr0$Recall==0),]))*100)
npv1 <- RRound(((nrow(table2yr1[which(table2yr1$Recall==0 & table2yr1$IntervalCancer == 0),]))/nrow(table2yr1[which(table2yr1$Recall==0),]))*100)
npv2 <- RRound(((nrow(table2yr2[which(table2yr2$Recall==0 & table2yr2$IntervalCancer == 0),]))/nrow(table2yr2[which(table2yr2$Recall==0),]))*100)

#CIs for sens
npv0UCI <- (binom.confint(x = (nrow(table2yr0[which(table2yr0$Recall==0 & table2yr0$IntervalCancer == 0),])), n = nrow(table2yr0[which(table2yr0$Recall==0),]), methods = "exact")$upper)*100
npv0LCI <- (binom.confint(x = (nrow(table2yr0[which(table2yr0$Recall==0 & table2yr0$IntervalCancer == 0),])), n = nrow(table2yr0[which(table2yr0$Recall==0),]), methods = "exact")$lower)*100

npv1UCI <- (binom.confint(x = (nrow(table2yr1[which(table2yr1$Recall==0 & table2yr1$IntervalCancer == 0),])), n = nrow(table2yr1[which(table2yr1$Recall==0),]), methods = "exact")$upper)*100
npv1LCI <- (binom.confint(x = (nrow(table2yr1[which(table2yr1$Recall==0 & table2yr1$IntervalCancer == 0),])), n = nrow(table2yr1[which(table2yr1$Recall==0),]), methods = "exact")$lower)*100

npv2UCI <- (binom.confint(x = (nrow(table2yr2[which(table2yr2$Recall==0 & table2yr2$IntervalCancer == 0),])), n = nrow(table2yr2[which(table2yr2$Recall==0),]), methods = "exact")$upper)*100
npv2LCI <- (binom.confint(x = (nrow(table2yr2[which(table2yr2$Recall==0 & table2yr2$IntervalCancer == 0),])), n = nrow(table2yr2[which(table2yr2$Recall==0),]), methods = "exact")$lower)*100

#Paste together
npv0label <- paste0(npv0, " (", RRound(npv0LCI), "-", RRound(npv0UCI), ")")
npv1label <- paste0(npv1, " (", RRound(npv1LCI), "-", RRound(npv1UCI), ")")
npv2label <- paste0(npv2, " (", RRound(npv2LCI), "-", RRound(npv2UCI), ")")






#This is the table for graphing data
ScreenType <- c(ST, ST, ST)
Year <- c(YL, YL, YL)
Statistics <- c("Sensitivity", "SensUCI", "SensLCI", "Specificity", "SpecUCI", "SpecLCI", "PPV", "PPVUCI", "PPVLCI", "NPV", "NPVUCI", "NPVLCI")
Overall <- c(sens0, sens0UCI, sens0LCI, spec0, spec0UCI, spec0LCI, ppv0, ppv0UCI, ppv0LCI, npv0, npv0UCI, npv0LCI)
OneReader <- c(sens1, sens1UCI, sens1LCI, spec1, spec1UCI, spec1LCI, ppv1, ppv1UCI, ppv1LCI, npv1, npv1UCI, npv1LCI)
TwoReader <- c(sens2, sens2UCI, sens2LCI, spec2, spec2UCI, spec2LCI, ppv2, ppv2UCI, ppv2LCI, npv2, npv2UCI, npv2LCI)

Results <- data.frame(ScreenType, Year, Statistics, Overall,OneReader,TwoReader)

#This is the table for more polished labels for presenting as a table
ScreenType <- c(ST, ST, ST, ST, ST, ST, ST, ST)
Year <- c(YL, YL, YL, YL, YL, YL, YL, YL)
Statistics <- c("TP", "FP", "TN", "FN", "Sensitivity", "Specificity", "PPV", "NPV")
Overall <- c(tp0, fp0, tn0, fn0, sens0label, spec0label, ppv0label, npv0label)
OneReader <- c(tp1, fp1, tn1, fn1, sens1label, spec1label, ppv1label, npv1label)
TwoReader <- c(tp2, fp2, tn2, fn2, sens2label, spec2label, ppv2label, npv2label)

Results2 <- data.frame(ScreenType, Year, Statistics, Overall,OneReader,TwoReader)

#Binding the tables together
ResultsAll <- rbind(ResultsAll, Results)
ResultsAll2 <- rbind(ResultsAll2, Results2)

} }

#These are the statistics of interest so put this in a list to filter on later
statslist <- c("Sensitivity", "Specificity", "PPV", "NPV")

#Getting prevalent information for the statistics wanted
ResultsAllPrint1 <- ResultsAll2 %>% arrange(Statistics, Year) %>% filter(ScreenType == "Prevalent" & Statistics %in% statslist) 
ResultsAllPrint1$ScreenType <- NULL
ResultsAllPrint1$'Overall - P' <- ResultsAllPrint1$Overall
ResultsAllPrint1$'OneReader - P' <- ResultsAllPrint1$OneReader
ResultsAllPrint1$'TwoReader - P' <- ResultsAllPrint1$TwoReader
ResultsAllPrint1$Overall <- NULL
ResultsAllPrint1$OneReader <- NULL
ResultsAllPrint1$TwoReader <- NULL

#Getting incident information for the statistics wanted
ResultsAllPrint2 <- ResultsAll2 %>% arrange(Statistics, Year) %>% filter(ScreenType == "Incident" & Statistics %in% statslist)
ResultsAllPrint2$ScreenType <- NULL
ResultsAllPrint2$'Overall - I' <- ResultsAllPrint2$Overall
ResultsAllPrint2$'OneReader - I' <- ResultsAllPrint2$OneReader
ResultsAllPrint2$'TwoReader - I' <- ResultsAllPrint2$TwoReader
ResultsAllPrint2$Overall <- NULL
ResultsAllPrint2$OneReader <- NULL
ResultsAllPrint2$TwoReader <- NULL

#Merge the above on year and statistics
ResultsAllPrint <- ResultsAllPrint1 %>% right_join(ResultsAllPrint2, by=c("Statistics","Year"))
       
#Print table
     kable(ResultsAllPrint
 , caption = paste0("**Table ", tablenum, ": Recall Accuracy by Reader Number and Year", "**") , padding=-1L, row.names = FALSE  )
     
       tablenum <- tablenum + 1
       

 #Okay for some reason I use the table data to create the graph data instead of just using the other dataset I created for the graphs, why I did this I do not know      
  ResultsAllLong <-  melt(ResultsAll2, id.vars=c("Year", "Statistics", "ScreenType"))
  
  statslist2 <- c("Sensitivity", "Specificity",  "PPV")
  ResultsAllLong <- ResultsAllLong %>% filter(Statistics %in% statslist2)
  

ResultsAllLong <- separate(ResultsAllLong, value, into = c("value", "ci"), sep = " (?=[^ ]+$)")
  
  ResultsAllLong$lower =  as.numeric(sub(".*?(\\d+\\.\\d+).*", "\\1", ResultsAllLong$ci))
  ResultsAllLong$upper =  as.numeric(sub(".*\\b(\\d+\\.\\d+).*", "\\1", ResultsAllLong$ci))
  
  ResultsAllLong <- ResultsAllLong %>% filter(variable != "Overall")
  ResultsAllLong$value <- as.numeric(ResultsAllLong$value)
  

ppvmin <- min(ResultsAllLong[which(ResultsAllLong$Statistics=="PPV"),]$lower)
ppvmax<- max(ResultsAllLong[which(ResultsAllLong$Statistics=="PPV"),]$upper)
  
  sensmin <- min(ResultsAllLong[which(ResultsAllLong$Statistics=="Sensitivity"),]$lower)
  sensmax<- max(ResultsAllLong[which(ResultsAllLong$Statistics=="Sensitivity"),]$upper)
  
  specmin <- min(ResultsAllLong[which(ResultsAllLong$Statistics=="Specificity"),]$lower)
  specmax<- max(ResultsAllLong[which(ResultsAllLong$Statistics=="Specificity"),]$upper)
  
ResultsAllLong$variable <- ifelse(ResultsAllLong$variable == "OneReader", "Single reading", "Double reading")
       
      
  
 

       
     #Graph      
      jpeg("C:\\Users\\u4111872\\Downloads\\UGH\\graphs\\OneVTwoDraftGraph4again.png", width = 3700, height = 2200, res=400)
      
 argh <-    ResultsAllLong %>%
  ggplot( aes(x=as.factor(Year), y=as.numeric(value), group = variable, color = variable)) +
    geom_line(size = 1.2) +   theme_minimal()+ geom_point(size = 1.5, shape = 21, fill = "white") +
  geom_errorbar( aes(ymin = lower, ymax = upper), width = 0.4, size = 1) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
#  scale_x_continuous(breaks = outputall$Group.1) +
  scale_color_manual(values = c("#00AFBB", "#E7B800")) +
  theme(legend.position = "bottom") + ggtitle("Statistics over time by reader number") +
  xlab("Year") + ylab("Percent") + facet_wrap(~ ScreenType+Statistics, scales = "free", ncol = 3) 
 
 argh +
  ggh4x::facetted_pos_scales(
    y = list(
      Statistics == "PPV" ~ scale_y_continuous(limits  = c(ppvmin, ppvmax)),
      Statistics == "Sensitivity" ~ scale_y_continuous(limits  = c(sensmin, sensmax)),
      Statistics == "Specificity" ~ scale_y_continuous(limits  = c(specmin, specmax))
    )
  )
 

     
      invisible(dev.off())
      

      
      
#Below here is a mess but basically it is looking at the percentage of recall, cancers, false positive recall, interval cancer, and it does this by year by screen type and by reader group for everything and then creates a graph at the end to see if over 1990-2006 there were any weird differences between one and two reader in respect to all of this, don't think this graph is in the draft it was just for checking to make sure weird things weren't going on we didn't have to account for

   table2p1 <- table2 %>% filter(ScreenType == "Prevalent" & Group == "One reader")
table2p2 <- table2 %>% filter(ScreenType == "Prevalent" & Group == "More than one reader")


table2i1 <- table2 %>% filter(ScreenType != "Prevalent" & Group == "One reader")
table2i2 <- table2 %>% filter(ScreenType != "Prevalent" & Group == "More than one reader")


#Prevalent - Recall

 outputall1 <- aggregate(table2p1$Recall, list(table2p1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2p2$Recall, list(table2p2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2p1$Recall, table2p1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2p2$Recall, table2p2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallRecall1 <- rbind(outputall, outputallp)
        outputallRecall1$Outcome <- "Recall"
       outputallRecall1$Type <- "Prevalent"
       
       
       #Incident - Recall

 outputall1 <- aggregate(table2i1$Recall, list(table2i1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2i2$Recall, list(table2i2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2i1$Recall, table2i1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2i2$Recall, table2i2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallRecall2 <- rbind(outputall, outputallp)
        outputallRecall2$Outcome <- "Recall"
       outputallRecall2$Type <- "Incident"
       
    outputallRecall <- rbind(outputallRecall1, outputallRecall2)    
    
    
    #Prevalent - Cancer

 outputall1 <- aggregate(table2p1$Cancer, list(table2p1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2p2$Cancer, list(table2p2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2p1$Cancer, table2p1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2p2$Cancer, table2p2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallCancer1 <- rbind(outputall, outputallp)
        outputallCancer1$Outcome <- "Cancer"
       outputallCancer1$Type <- "Prevalent"
       
       
       #Incident - Cancer

 outputall1 <- aggregate(table2i1$Cancer, list(table2i1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2i2$Cancer, list(table2i2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2i1$Cancer, table2i1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2i2$Cancer, table2i2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallCancer2 <- rbind(outputall, outputallp)
        outputallCancer2$Outcome <- "Cancer"
       outputallCancer2$Type <- "Incident"
       
    outputallCancer <- rbind(outputallCancer1, outputallCancer2)  
    
    
    
        #Prevalent - Interval Cancer

 outputall1 <- aggregate(table2p1$IntervalCancer, list(table2p1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2p2$IntervalCancer, list(table2p2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2p1$IntervalCancer, table2p1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2p2$IntervalCancer, table2p2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallIntervalCancer1 <- rbind(outputall, outputallp)
        outputallIntervalCancer1$Outcome <- "Interval Cancer"
       outputallIntervalCancer1$Type <- "Prevalent"
       
       
       #Incident - IntervalCancer

 outputall1 <- aggregate(table2i1$IntervalCancer, list(table2i1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2i2$IntervalCancer, list(table2i2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2i1$IntervalCancer, table2i1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2i2$IntervalCancer, table2i2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallIntervalCancer2 <- rbind(outputall, outputallp)
        outputallIntervalCancer2$Outcome <- "Interval Cancer"
       outputallIntervalCancer2$Type <- "Incident"
       
    outputallIntervalCancer <- rbind(outputallIntervalCancer1, outputallIntervalCancer2)  
    
    
    
    #Need to add next cancer and FP here
    
            #Prevalent - Next Cancer

 outputall1 <- aggregate(table2p1$NextCancer, list(table2p1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2p2$NextCancer, list(table2p2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2p1$NextCancer, table2p1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2p2$NextCancer, table2p2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallNextCancer1 <- rbind(outputall, outputallp)
        outputallNextCancer1$Outcome <- "Next Cancer"
       outputallNextCancer1$Type <- "Prevalent"
       
       
       #Incident - Next Cancer

 outputall1 <- aggregate(table2i1$NextCancer, list(table2i1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2i2$NextCancer, list(table2i2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2i1$NextCancer, table2i1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2i2$NextCancer, table2i2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallNextCancer2 <- rbind(outputall, outputallp)
        outputallNextCancer2$Outcome <- "Next Cancer"
       outputallNextCancer2$Type <- "Incident"
       
    outputallNextCancer <- rbind(outputallNextCancer1, outputallNextCancer2)  
    
    
                #Prevalent - False Positive Recall

 outputall1 <- aggregate(table2p1$FalsePositiveRecall, list(table2p1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2p2$FalsePositiveRecall, list(table2p2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2p1$FalsePositiveRecall, table2p1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2p2$FalsePositiveRecall, table2p2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallFalsePositive1 <- rbind(outputall, outputallp)
        outputallFalsePositive1$Outcome <- "False Positive"
       outputallFalsePositive1$Type <- "Prevalent"
       
       
       #Incident - Next Cancer

 outputall1 <- aggregate(table2i1$FalsePositiveRecall, list(table2i1$Year), mean, na.rm = TRUE)
  outputall2 <- aggregate(table2i2$FalsePositiveRecall, list(table2i2$Year), mean, na.rm = TRUE)
  
  #CI 1
  outputallCI <- as.data.frame(table(table2i1$FalsePositiveRecall, table2i1$Year))
  outputallCI <- spread(outputallCI, Var1, Freq)
  outputallCI$Total <- outputallCI$`0` + outputallCI$`1`
  outputallCI$p <- (outputallCI$`1`/outputallCI$Total)*100
    outputallCI$UCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$upper)*100
    outputallCI$LCI <- (binom.confint(x = outputallCI$`1`, n = outputallCI$Total, methods = "exact")$lower)*100
    outputallCI$Group.1 <- outputallCI$Var2
    outputallCI$Var2 <- NULL
    
    
          #CI 2
  outputallCIP <- as.data.frame(table(table2i2$FalsePositiveRecall, table2i2$Year))
  outputallCIP <- spread(outputallCIP, Var1, Freq)
  outputallCIP$Total <- outputallCIP$`0` + outputallCIP$`1`
  outputallCIP$p <- (outputallCIP$`1`/outputallCIP$Total)*100
    outputallCIP$UCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$upper*100 
    outputallCIP$LCI <- binom.confint(x = outputallCIP$`1`, n = outputallCIP$Total, methods = "exact")$lower*100 
      outputallCIP$Group.1 <- outputallCIP$Var2
    outputallCIP$Var2 <- NULL
    
        outputall <- merge(x=outputall1, y=outputallCI, by="Group.1",all.x=TRUE)
    outputallp <- merge(x=outputall2, y=outputallCIP, by="Group.1",all.x=TRUE)
    
    #Need to merge again
    outputall$Group <- "One reader"
    outputallp$Group <- "Two reader"
    
    outputallFalsePositive2 <- rbind(outputall, outputallp)
        outputallFalsePositive2$Outcome <- "False Positive"
       outputallFalsePositive2$Type <- "Incident"
       
    outputallFalsePositive <- rbind(outputallFalsePositive1, outputallFalsePositive2)  
    
    
    
    
      outputall <- rbind(outputallRecall, outputallFalsePositive,  outputallCancer, outputallIntervalCancer,  outputallNextCancer )
    
  icmin <- min(outputall[which(outputall$Outcome=="Interval Cancer"),]$LCI)
  icmax<- max(outputall[which(outputall$Outcome=="Interval Cancer"),]$UCI)
  
  cmin <- min(outputall[which(outputall$Outcome=="Cancer"),]$LCI)
  cmax<- max(outputall[which(outputall$Outcome=="Cancer"),]$UCI)
  
  rmin <- min(outputall[which(outputall$Outcome=="Recall"),]$LCI)
  rmax<- max(outputall[which(outputall$Outcome=="Recall"),]$UCI)
  
  fpmin <- min(outputall[which(outputall$Outcome=="False Positive"),]$LCI)
  fpmax<- max(outputall[which(outputall$Outcome=="False Positive"),]$UCI)
  
  ncmin <- min(outputall[which(outputall$Outcome=="Next Cancer"),]$LCI)
  ncmax<- max(outputall[which(outputall$Outcome=="Next Cancer"),]$UCI)

    outputall$Outcome <- ordered(outputall$Outcome, levels = c("Recall", "False Positive", "Cancer", "Interval Cancer", "Next Cancer"))
    
        jpeg("C:\\Users\\u4111872\\Downloads\\UGH\\graphs\\OneVTwoDraftGraph5a.png", width = 2200, height = 4200, res=400)
      
  argh<-   outputall %>% filter(Group.1 > 1989 & Group.1 < 2007) %>% 
  ggplot( aes(x=Group.1, y=p, group=Group, color=Group)) +
    geom_line() +   theme_minimal()+ 
  geom_errorbar( aes(ymin = LCI, ymax = UCI),width = 0.2) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  scale_x_continuous(breaks = outputall$Group.1) +
  scale_color_manual(values = c("#00AFBB", "#E7B800")) +
  theme(legend.position = "bottom") + ggtitle("Outcome by Screen Type and Reader Number") +
  xlab("Year") + ylab("Percentage")  + facet_wrap(~Outcome+Type, scales = "free", ncol = 2)
  
   argh +
  ggh4x::facetted_pos_scales(
    y = list(
      Outcome == "Interval Cancer" ~ scale_y_continuous(limits  = c(icmin, icmax)),
      Outcome == "Cancer" ~ scale_y_continuous(limits  = c(cmin, cmax)),
      Outcome == "Next Cancer" ~ scale_y_continuous(limits  = c(ncmin, ncmax)),
      Outcome == "False Positive" ~ scale_y_continuous(limits  = c(fpmin, fpmax)),
      Outcome == "Recall" ~ scale_y_continuous(limits  = c(rmin, rmax))
    )
  )
     
      invisible(dev.off())

    
    #Clean up  
      rm(outputall)
      rm(outputall1)
      rm(outputall2)
      rm(outputallcancer)
      rm(outputallCancer)
      rm(outputallCancer1)
      rm(outputallCancer2)
      rm(outputallCI)
      rm(outputallCIP)
      rm(outputallic)
      rm(outputallIntervalCancer)
      rm(outputallIntervalCancer1)
      rm(outputallIntervalCancer2)
      rm(outputallp)
      rm(outputallrecall)
      rm(outputallRecall)
      rm(outputallRecall1)
      rm(outputallRecall2)
      
        rm(outputallNextCancer)
      rm(outputallNextCancer1)
      rm(outputallNextCancer2)
      
        rm(outputallFalsePositive)
      rm(outputallFalsePositive1)
      rm(outputallFalsePositive2)
      
      rm(table2i)
      rm(table2i1)
      rm(table2i2)
      rm(table2p)
      rm(table2p1)
      rm(table2p2)
      
        
#Fig numbering I haven't really kept updated  
fignum1 <-     fignum

fignum + 1

fignum2 <- fignum

fignum + 1


```



 
 ![](C:\\Users\\u4111872\\Downloads\\UGH\\graphs\\OneVTwoDraftGraph4.png)
 ![](C:\\Users\\u4111872\\Downloads\\UGH\\graphs\\OneVTwoDraftGraph5.png)
  
  
  
```{r AdditionalStatsNeeded, out.width='100%', results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}

#This is where I put some additional stats that were asked for but may have not made it into the main paper

#This part looks at what happens to disagreements in two reader screens, this does make it into the paper

#This gets the episode list for 1994-1999 screens
EpiYears <- SubsetList %>% filter(Subset == "Years")

#Pulls out two reader screens from 1994-1999 
table2years <- table2 %>% filter(EPISODEID %in% EpiYears$EPISODEID & Group == "More than one reader" & Screened == 1)

#Reads in more film reader details and joints with table 2
 readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedC.fst"
 creadlist <- c("EPISODEID",  "F1Cat2", "F2Cat2")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2years$F1Cat2 = table2a$F1Cat2[match(table2years$EPISODEID, table2a$EPISODEID)]
    table2years$F2Cat2 = table2a$F2Cat2[match(table2years$EPISODEID, table2a$EPISODEID)]
 rm(table2a)
 

 #Creates a reader group variable that assigns screens to agree to recall, agree to not recall, and then disagree
table2years$ReaderDecisions <- ifelse(table2years$F1Cat2 == table2years$F2Cat2 & table2years$F2Cat2 == "Do not recall", "Agree - No recall",
                            ifelse(table2years$F1Cat2 == table2years$F2Cat2 & table2years$F2Cat2 == "Recall for further tests", "Agree - Recall",       
                            ifelse(table2years$F1Cat2 != table2years$F2Cat2, "Disagree", NA       )))

#Checking here as there are some screens that don't fit cleanly into the above three categories, these were mainly readers with "Other" as a decision which was only a few thousands out of the millions
table(table2years$ReaderDecisions, useNA = "ifany")
check <- table2years %>% filter(is.na(ReaderDecisions)) %>% dplyr::select(F1Cat2, F2Cat2)


       
#Have a table breaking down yes yes recall, no no recall, and no yes recall by percent recall
 table2years %>% dplyr::select(RecallCat, ReaderDecisions) %>% tbl_summary(by = ReaderDecisions,   digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2)))

#Have a table breaking down yes yes recall, and no yes recall by percent cancer
 table2years %>% filter(ReaderDecisions %in% c("Agree - Recall", "Disagree") & Recall == 1) %>% dplyr::select(CancerCat, ReaderDecisions)  %>% tbl_summary(by = ReaderDecisions, digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2)))
 


#Here we tried to get an idea of arbitration by centre but it didn't turn out, here I am trying to look to see how things varied depending on arbitration method by centre/year
 
 #Read in arbitration guide which was calculated elsewhere, we didn't end up reporting on arbitration because we didn't think our way of trying to define it was good enough  
 arbguide <- read.csv("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\arbguide.csv")

#Since arbitration can differ overtime I tried to measure arbitration by centre and year so need to create a label like that to join on
table2years$OfficeIDYear <- paste0(table2years$OfficeID, "-", table2years$Year)

#Join arbitratiion category
table2years$ArbCat = arbguide$ArbCat[match(table2years$OfficeIDYear, arbguide$OfficeIDYear)]

#At labels to numbers
table2years$ArbCat <- ifelse(table2years$ArbCat == 0, "No arb",
                  ifelse(table2years$ArbCat == 1, "Arb",    
                    ifelse(table2years$ArbCat == 2, "Unsure arb",
                       NA )))

arbguide$ArbCat <- ifelse(arbguide$ArbCat == 0, "No arb",
                  ifelse(arbguide$ArbCat == 1, "Arb",    
                    ifelse(arbguide$ArbCat == 2, "Unsure arb",
                       NA )))

#Look to see how many fall in each category, it's about even if I remember
table(arbguide$ArbCat)


#Going back to looking at disagreements without breaking it down by arbitration groups
#Looking specifically at one reader stats 
table2years <- table2 %>% filter(EPISODEID %in% EpiYears$EPISODEID & Group == "One reader" & Screened == 1)

#Join needed information
 readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedC.fst"
 creadlist <- c("EPISODEID", "F1Cat2", "F2Cat2")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2years$F1Cat2 = table2a$F1Cat2[match(table2years$EPISODEID, table2a$EPISODEID)]
    table2years$F2Cat2 = table2a$F2Cat2[match(table2years$EPISODEID, table2a$EPISODEID)]
 rm(table2a)
 
 

#Have a table breaking down yes yes recall, no no recall, and no yes recall by percent recall
 table2years %>% dplyr::select(RecallCat, F1Cat2) %>% tbl_summary(by = F1Cat2, digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2)))

#Have a table breaking down yes yes recall, and no yes recall by percent cancer, also add one reader recall cancer
 table2years %>% filter( Recall == 1) %>% dplyr::select(CancerCat, F1Cat2)  %>% tbl_summary(by = F1Cat2, digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2)))
 

 
 
 
#Pull out two reader disagreements only again
EpiYears <- SubsetList %>% filter(Subset == "Years")
table2years <- table2 %>% filter(EPISODEID %in% EpiYears$EPISODEID & Screened == 1)

 readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedC.fst"
 creadlist <- c("EPISODEID",  "ReaderNum4", "F1Cat2", "F2Cat2")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2years$F1Cat2 = table2a$F1Cat2[match(table2years$EPISODEID, table2a$EPISODEID)]
    table2years$F2Cat2 = table2a$F2Cat2[match(table2years$EPISODEID, table2a$EPISODEID)]
    table2years$ReaderNum4 = table2a$ReaderNum4[match(table2years$EPISODEID, table2a$EPISODEID)]
 rm(table2a)
 

 
 #Reader decision again
table2years$ReaderDecisions <- ifelse(table2years$F1Cat2 == table2years$F2Cat2 & table2years$F2Cat2 == "Do not recall", "Agree - No recall",
                            ifelse(table2years$F1Cat2 == table2years$F2Cat2 & table2years$F2Cat2 == "Recall for further tests", "Agree - Recall",       
                            ifelse(table2years$F1Cat2 != table2years$F2Cat2, "Disagree", 
                                   
                                   ifelse(table2years$F1Cat2 == "Recall for further tests" & table2years$F2Cat == "", "Solo Recall",
                                   
                                   
                                   NA       ))))


#This part looks to see how many two reader screens (we call them more than one reader screens) were two reader screens as there is sometimes a third reader or a consesus reader or other things going on, this explores that a bit

#Pull out two reader disagreements only
EpiYears <- SubsetList %>% filter(Subset == "Years")
table2years <- table2 %>% filter(EPISODEID %in% EpiYears$EPISODEID & Screened == 1)

#Join a lot more information 
 readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedC.fst"
 creadlist <- c("EPISODEID",  "ReaderNum4", "FILMREADER1", "FILMREADER1RECACTION", "FILMREADERTYPE1", 
 "FILMREADER2",  "FILMREADER2RECACTION", "FILMREADERTYPE2", "F1Cat2", "F2Cat2",  "FILMREADER3", "FILMREADER3RECACTION", "FILMREADERTYPE3", "Consensus3", "Consensus")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)
 
 
 
   table2years$FILMREADER1 = table2a$FILMREADER1[match(table2years$EPISODEID, table2a$EPISODEID)]
      table2years$FILMREADER1RECACTION = table2a$FILMREADER1RECACTION[match(table2years$EPISODEID, table2a$EPISODEID)]
       table2years$FILMREADERTYPE1 = table2a$FILMREADERTYPE1[match(table2years$EPISODEID, table2a$EPISODEID)]
         table2years$FILMREADER2 = table2a$FILMREADER2[match(table2years$EPISODEID, table2a$EPISODEID)]
     table2years$FILMREADER2RECACTION = table2a$FILMREADER2RECACTION[match(table2years$EPISODEID, table2a$EPISODEID)]
     table2years$FILMREADERTYPE2 = table2a$FILMREADERTYPE2[match(table2years$EPISODEID, table2a$EPISODEID)]
          table2years$FILMREADER3 = table2a$FILMREADER3[match(table2years$EPISODEID, table2a$EPISODEID)]
             table2years$FILMREADER3RECACTION = table2a$FILMREADER3RECACTION[match(table2years$EPISODEID, table2a$EPISODEID)]
           table2years$FILMREADERTYPE3 = table2a$FILMREADERTYPE3[match(table2years$EPISODEID, table2a$EPISODEID)]
           table2years$Consensus3 = table2a$Consensus3[match(table2years$EPISODEID, table2a$EPISODEID)]
           table2years$Consensus = table2a$Consensus[match(table2years$EPISODEID, table2a$EPISODEID)]
     
    table2years$F1Cat2 = table2a$F1Cat2[match(table2years$EPISODEID, table2a$EPISODEID)]
    table2years$F2Cat2 = table2a$F2Cat2[match(table2years$EPISODEID, table2a$EPISODEID)]
 rm(table2a)
 
 #Reader number is based on number of actions (minus consensus) so create a valid that counts those reactions
table2years$ActionNumbers <- (is.na(table2years$FILMREADER1RECACTION) | table2years$FILMREADER1RECACTION != "") + 
                              (is.na(table2years$FILMREADER2RECACTION) | table2years$FILMREADER2RECACTION != "") + 
                                (is.na(table2years$FILMREADER3RECACTION) | table2years$FILMREADER3RECACTION != "")

#Look to see how action numbers vary by our current one and two reader definition
table(table2years$Group, table2years$ActionNumbers)

#Agree recall subset for data exploration, this is jsut checking to see if there is anything weird going on
agreerecall <- table2years %>% filter( (F1Cat2 == "Recall for further tests" & F2Cat2 == "Recall for further tests") | ( F1Cat2 == "Recall for further tests" & is.na(F2Cat2)))


```  
  


### Does number of readers relate to recalls/false positive recalls/cancer detection?


```{r Screen Models Analysis, out.width='100%', results = "asis", eval = FALSE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}


#This is the main screening outcome model analysis code chunk. It has the multi level models with various screening outcomes and then loops these through the different screening types (prevalent and incident) and through the different data subsets

#List of outcome variables looked at
OutcomeVariables <- c("Recall", "FalsePositiveRecall", "Cancer", "Cancer2", "IntervalCancer",  "IntervalCancer1Y", "IntervalCancer2Y",  "NextCancer")

#Code below is if a smaller number of variables needed to be ran
#OutcomeVariables <- c("Cancer2", "IntervalCancer")


#This chunk was designed to run independently so basically everything is read in again
  creadlist <- c("PATIENTID", "FirstScreenID", "LastAgeOffered", "LastOfferEpisode", "IMDQUINTILE")
table0 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\Table0.fst", columns = creadlist)





#Read in table2 information
   creadlist <- c( "EPISODEID", "PATIENTID", "OfficeID", "CANCEROUTCOMEFLAG", "dateoffirstofferedappointmentcalc",  "AgeCalc", "Screened")
    readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst"
table2 <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

#Read in exclusion
exclusion <- read.csv("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\episodeexcludelist.csv")

table2$Year <- lubridate::year(table2$dateoffirstofferedappointmentcalc)

#Filter to screened episodes and exclude episoeds that are in the exclusions list 
table2 <- table2 %>% filter(EPISODEID %notin% exclusion$EPISODEID  & Screened == 1)


#Table 0 join and clean up, here we have an old definition of screen type that includes "last screen" which is no longer used so instead this basically just looks at screen types that are prevalent type or not (so if they are not prevalent they are incident and we don't care if it is last screen or not here)

    table2$LastAgeOffered = table0$LastAgeOffered[match(table2$PATIENTID, table0$PATIENTID)]

table2$ScreenType <- ifelse(table2$EPISODEID %in% table0$FirstScreenID, "Prevalent ",
                      ifelse(table2$EPISODEID %in% table0$LastOfferEpisode & table2$LastAgeOffered > 61, "Last",   "Incident"    ))


 table0$IMDQUINTILE <- as.character(table0$IMDQUINTILE)
table0$IMDQUINTILE[table0$IMDQUINTILE==""] <- NA
table0$IMDQUINTILE <- as.factor(table0$IMDQUINTILE)

 table2$IMDQUINTILE = table0$IMDQUINTILE[match(table2$PATIENTID, table0$PATIENTID)]

rm(table0)
rm(exclusion)



#Read in reader information 
  readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedC.fst"
 creadlist <- c("EPISODEID",  "ReaderNum4", "FILMREADER1", "FILMREADER1RECACTION",
 "FILMREADER2",  "FILMREADER2RECACTION", "F1Cat2", "F2Cat2")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2$ReaderNum4 = table2a$ReaderNum4[match(table2$EPISODEID, table2a$EPISODEID)]
 rm(table2a)
 
 
#Read in more screening outcomes
   readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst"
 creadlist <- c("EPISODEID",  "Recall", "FalsePositiveRecall")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2$Recall = table2a$Recall[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$FalsePositiveRecall = table2a$FalsePositiveRecall[match(table2$EPISODEID, table2a$EPISODEID)]
 rm(table2a)

 #Create number screen cancer variable
 table2$Cancer <- ifelse(table2$CANCEROUTCOMEFLAG == "Y", 1,
                    ifelse(table2$CANCEROUTCOMEFLAG == "N", 0,  NA    ))

 #Numeric recall variable
table2$Recall <- ifelse(table2$Recall == 1, 1, 0)

#Numeric false positive recall variable
table2$FalsePositiveRecall <- ifelse(table2$FalsePositiveRecall == 1, 1, 0)


#Reader group variable
 table2$Group <- ifelse(table2$ReaderNum4 == 1, "One reader", ifelse(table2$ReaderNum4 > 1, "More than one reader", NA))

#Get reader counts to calculate reader experience variable
   readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2recalljoinedpairs.fst"
 creadlist <- c("EPISODEID", "RecallAllCountF1", "RecallAllCountF2")
 table2a <- read.fst(readlink, from = fromnum, to = tonum, columns = creadlist)
 
table2a <- table2a %>% rowwise() %>% mutate(ReaderExp=mean(c(RecallAllCountF1, RecallAllCountF2), na.rm=T)) 

#Because reader experience is such a large variable I scale it to be smaller in the model so every unit represents a 10k increase
      table2$ReaderExp = table2a$ReaderExp[match(table2$EPISODEID, table2a$EPISODEID)]
         table2$ReaderExp <- table2$ReaderExp/10000

  #Clean up       
 rm(table2a)
 
 



#Since we are looking at rare outcomes (like cancer and interval cancer) the models sometimes have problems when there are too few in certain subgroups (so not having a cancer in a one reader prevalent screen), in order to get around this but still have some sort of clustering effect for centre I created a new variable where centre ID with less than 100k screens overall are group with their "nearest" centre (nearest centre being the most common centre that people from that centre used if they attended more than 1), there were also three centres that transitioned to two reader pretty soon which meant they still didn't have very many events (1 or 0) in certain subgroups so those three were also put with their nearest centre, code for this can be seen in the "Grouping centres based on patients centre overlaps" chunk of the FrankenCode
 table2$OfficeID1Plus <- ifelse(table2$OfficeID == "S032", "S006",
                          ifelse(table2$OfficeID == "S050", "S009",
                              ifelse(table2$OfficeID == "S077", "S079",
                                  ifelse(table2$OfficeID == "S078", "S071",
                                    ifelse(table2$OfficeID == "S081", "S071",
                                        ifelse(table2$OfficeID == "S083", "S021",
                                          ifelse(table2$OfficeID == "S084", "S079",
                                              ifelse(table2$OfficeID == "S027", "S023",
                                                  ifelse(table2$OfficeID == "S061", "S015",
                                                      ifelse(table2$OfficeID == "S007", "S074", table2$OfficeID
                                                              ))))))))))

#Trying to get rid of columns no longer needed in a vain attempt to speed up this code
#table2$CANCEROUTCOMEFLAG <- NULL
#table2$Screened <- NULL
#table2$ReaderNum4 <- NULL


#Need to join cancer data here to see what is an interval cancer
table4 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table4.fst")
 
#Create cancer type variable
        table4$Type <- ifelse(table4$SDDCISInvasive == 1, "DCIS",
                                ifelse(table4$SDDCISInvasive == 2, "Invasive", "Missing"))


 #Want to get just one tumor per screening episode using the nearest screening episode before or within 1 week of the tumor, we want to do this by keeping the most severe cancer a screening found if that screen found multiple cancers

#Factor invasive and dcis grade to go from most severe tumor to least severe tumor 
    table4$SDInvasiveGrade2 <- factor(table4$SDInvasiveGrade, levels = c("G3", "G2", "G1", "GX", "Other", "Miscode", "Missing", "DCIS"))
    table4$SDDCISGrade2 <- factor(table4$SDDCISGrade, levels = c("GH", "GI", "GL", "GX", "Other", "Miscode", "Missing", "Invasive"))

    
#Put this table into another table to be able to mess around with
table4sub <- table4 



 

#New linking system to make sure we get the most extreme tumour per episode if multiple tumors were detected
  table4sub <- table4sub   %>%  group_by(EPISODEIDLink)  %>% arrange(EPISODEIDLink,  desc(ScreenedTumor), desc(SDDCISInvasive), SDInvasiveGrade2, SDDCISGrade2, desc(SDInvasiveSize), desc(SDDCISSize), ClosestDays, PSEUDO_TUMOURID)
  

  
table4sub <-  table4sub[!duplicated(table4sub$EPISODEIDLink),]


 #Make sure if there is no data in the screened tumor variable it defaults to not being screened
table4sub$ScreenedTumor[is.na(table4sub$ScreenedTumor)] = 0

#Matches data from table4sub (where there is only one cancer per screen) to table 2
   table2$EPISODEIDLink = table4sub$EPISODEIDLink[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
    table2$ClosestDays = table4sub$ClosestDays[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
      table2$ScreenedTumor = table4sub$ScreenedTumor[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
       table2$Type = table4sub$Type[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
        table2$diagnosisdatebest = table4$diagnosisdatebest[match(table2$EPISODEID, table4$EPISODEIDLink)]
      
#Clean up
   rm(table4)
  rm(table4sub)

  #Create another cancer definition where it is only counted if it is invasive   
  table2$Cancer2 <- ifelse(table2$Cancer == 1 & table2$Type == "Invasive" & table2$ScreenedTumor == 1 & !is.na(table2$Type), 1, 0)



#This line gets rid of cancers that occur after non attended invite but within time of screening, so if there was a cancer that appeared 3.5 years after a screened episode but they missed a screening episode at 3 years then those aren't considered interval cancers
daysnext   <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\daysbetweeninvite2.fst")


#Match the days to next invite data to table 2
table2$NextInviteDays = daysnext$NextInviteDays[match(table2$EPISODEID, daysnext$EPISODEID)]



#New less crap interval cancer code
table2$IntervalCancer <- ifelse(
  table2$Cancer == 1,  # if cancer was screen-detected (from table2), not interval
  0,
  ifelse(
    table2$ScreenedTumor == 0 &  # must be a cancer from table4, not screen-detected
    table2$ClosestDays < 1278 & 
    (is.na(table2$NextInviteDays) | table2$ClosestDays < table2$NextInviteDays),
    1, 0
  )
)

table2$IntervalCancer[is.na(table2$IntervalCancer)] = 0

table2$IntervalCancer1Y <- ifelse(
  table2$Cancer == 1,  # if cancer was screen-detected (from table2), not interval
  0,
  ifelse(
    table2$ScreenedTumor == 0 &  # must be a cancer from table4, not screen-detected
    table2$ClosestDays < 366 & 
    (is.na(table2$NextInviteDays) | table2$ClosestDays < table2$NextInviteDays),
    1, 0
  )
)

table2$IntervalCancer1Y[is.na(table2$IntervalCancer1Y)] = 0

table2$IntervalCancer2Y <- ifelse(
  table2$Cancer == 1,  # if cancer was screen-detected (from table2), not interval
  0,
  ifelse(
    table2$ScreenedTumor == 0 &  # must be a cancer from table4, not screen-detected
    table2$ClosestDays < 730 & 
    (is.na(table2$NextInviteDays) | table2$ClosestDays < table2$NextInviteDays),
    1, 0
  )
)

table2$IntervalCancer2Y[is.na(table2$IntervalCancer2Y)] = 0

#Also match previous and next episode ID to table 2
  table2$PreviousInviteID = daysnext$PreviousInviteID[match(table2$EPISODEID, daysnext$EPISODEID)]
    table2$NextInviteID = daysnext$NextInviteID[match(table2$EPISODEID, daysnext$EPISODEID)]

  #Create a back up of table 2
table2bu <- table2

#Then we are creating a next cancer variable that is seeing if there was a cancer at the next screen
table2$NextCancer = table2bu$Cancer[match(table2$EPISODEID, table2bu$PreviousInviteID)]

#clean up
rm(table2bu)



#Here we create two datasets, one with prevalent screens and one with non prevalent screens (so incident screens)
Prevalent  <- table2 %>% filter(ScreenType == "Prevalent ")
Incident <- table2 %>% filter(ScreenType != "Prevalent ")


Prevalent$Type <- "Prevalent "
Incident$Type <- "Incident"

#This creates a list of these dataframes to loop through
ScreenTypeList <- list(Prevalent , Incident)

#This backs up table 2 again as later in the code table 2 is what is being used for the analysis code
table2bu <- table2
#table2 <- table2bu


#Do sensitivity analysis here for incident screens and prevalent screens Years Recall Only Outcome, this just adds in IMD quintile for the recall rate variable, since IMD is 5 categories it was difficult to keep for all outcomes (such as cancers) as there would be too many subgroups with 0 cancers but here we are seeing if the recall model is still similar to the recall rate model without IMD, this was just manually ran and put into the paper so it is commented out here
# 
# Time <- "Years"
#    Epilist <- SubsetList %>% filter(Subset %in% Time)
# 
#            senstable1 <- table2 %>% filter(EPISODEID %in% Epilist$EPISODEID & ScreenType != "Prevalent " & Screened == 1)
# 
# 
# 
# m1 <- glmer(as.numeric(Recall) ~  relevel(as.factor(Group), ref = 'One reader') + Year + AgeCalc + ReaderExp + IMDQUINTILE + (1  | PATIENTID) + (1|OfficeID1Plus),
#  data=senstable1,  na.action = na.omit, family="binomial",
#        nAGQ = 0,
#     control = glmerControl(optimizer = "nloptwrap", calc.derivs = FALSE, optCtrl = list(maxfun=1000)))
# # 
# outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1IMDSensIncident.xlsx")
#   fit2df(m1, metrics=TRUE, digits = c(5,5,5), explanatory_name = "Variable") -> t1
# 
# ARGH <- broom::tidy(m1, conf.int = TRUE, exponentiate=TRUE, effects="fixed")
# ARGH$effect <- NULL
# ARGH$std.error <- NULL
# ARGH$Variable <- ARGH$term
# ARGH$term <- NULL
# ARGH$estimate <- round(ARGH$estimate, 3)
# ARGH$p.value <- round(ARGH$p.value, 3)
# ARGH$conf.low <- round(ARGH$conf.low, 3)
# ARGH$conf.high <- round(ARGH$conf.high, 3)
# ARGH$statistic <- NULL
# ARGH$PValueLabel <- ifelse(ARGH$p.value < .001, paste0("p<.001"), paste0("p=", ARGH$p.value))
# ARGH$OR <- paste0(ARGH$estimate, " (", ARGH$conf.low, " to ", ARGH$conf.high, ", ", ARGH$PValueLabel, ")")
# ARGH <- ARGH %>% dplyr::select(Variable, OR) %>% filter(Variable != "(Intercept)")
# # 
#     xlsx::write.xlsx(as.data.frame(ARGH), outputfile, sheetName="Sheet1", row.names = FALSE)
#     xlsx::write.xlsx(as.data.frame(t1[2]), outputfile, sheetName="Sheet2", append=TRUE, row.names = FALSE)
# 
#         rm(m1)
#         invisible(gc())
# 
# 
# 
#            senstable2 <- table2 %>% filter(EPISODEID %in% Epilist$EPISODEID & ScreenType == "Prevalent " & Screened == 1)
# 
# 
# 
# m1 <- glmer(as.numeric(Recall) ~  relevel(as.factor(Group), ref = 'One reader') + Year + AgeCalc + ReaderExp + IMDQUINTILE +  (1|OfficeID1Plus),
#  data=senstable2,  na.action = na.omit, family="binomial",
#        nAGQ = 0,
#     control = glmerControl(optimizer = "nloptwrap", calc.derivs = FALSE, optCtrl = list(maxfun=1000)))
# 
# outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1IMDSensPrevalent.xlsx")
#   fit2df(m1, metrics=TRUE, digits = c(5,5,5), explanatory_name = "Variable") -> t1
# 
# ARGH <- broom::tidy(m1, conf.int = TRUE, exponentiate=TRUE, effects="fixed")
# ARGH$effect <- NULL
# ARGH$std.error <- NULL
# ARGH$Variable <- ARGH$term
# ARGH$term <- NULL
# ARGH$estimate <- round(ARGH$estimate, 3)
# ARGH$p.value <- round(ARGH$p.value, 3)
# ARGH$conf.low <- round(ARGH$conf.low, 3)
# ARGH$conf.high <- round(ARGH$conf.high, 3)
# ARGH$statistic <- NULL
# ARGH$PValueLabel <- ifelse(ARGH$p.value < .001, paste0("p<.001"), paste0("p=", ARGH$p.value))
# ARGH$OR <- paste0(ARGH$estimate, " (", ARGH$conf.low, " to ", ARGH$conf.high, ", ", ARGH$PValueLabel, ")")
# ARGH <- ARGH %>% dplyr::select(Variable, OR) %>% filter(Variable != "(Intercept)")
# 
#     xlsx::write.xlsx(as.data.frame(ARGH), outputfile, sheetName="Sheet1", row.names = FALSE)
#     xlsx::write.xlsx(as.data.frame(t1[2]), outputfile, sheetName="Sheet2", append=TRUE, row.names = FALSE)

#         rm(m1)
#         invisible(gc())

#This is the range of times to loop through
  TimeRange <- c("Years", "Years0T", "Year", "Four", "Two", "Year ST Centres", "2080 Exclude 1", "2080 Exclude 2")

  #Testing variables
  # Time <- "Years"
# OV <- "IntervalCancer"
  # ST2 <- Incident

  
#Start of the loops
   for(Time in TimeRange){

for (OV in OutcomeVariables) {

for (ST2 in ScreenTypeList) {

  #This takes either the prevalent or incident screen dataset and assigns it to table2 
  table2 <- ST2
 
  #Creates a screen type label for later  
  ST <- table2$Type[1]
  
  #This drops empty levels from table 2
  table2 <- droplevels(table2)
  
  #This gets the episode list of interest
   Epilist <- SubsetList %>% filter(Subset %in% Time)
           
   #This filters table2 on episode of interest, since the subsetlist already filters on exclusion episodes (and in the above code it does that as well) exclusion filtering isn't needed here
           table2 <- table2 %>% filter(EPISODEID %in% Epilist$EPISODEID)
 
#We initially was going to look at recall rate and one and two reader in the same draft and sample but that has changed, formula 2 was originally the recall rate model but that is no longer used here, formula1 is the formula to use, for incident screens there is a patient level cluster but there isn't one for prevalent screens which is the only different between these models, model also then uses the outcome variable that is being used

  formula1 <- ifelse(ST == "Incident", paste0("as.numeric(", OV, ") ~  relevel(as.factor(Group), ref = 'One reader') + Year + AgeCalc + ReaderExp  + (1  | PATIENTID) + (1|OfficeID1Plus)"),  paste0("as.numeric(", OV, ") ~   relevel(as.factor(Group), ref = 'One reader') + Year + AgeCalc + ReaderExp   + (1|OfficeID1Plus)") )

    # formula2 <- ifelse(ST == "Incident", paste0("as.numeric(", OV, ") ~ Threshold500P  + Year + AgeCalc + ReaderExp  + (1  | PATIENTID) + (1|OfficeID1Plus)"),  paste0("as.numeric(", OV, ") ~ Threshold500P  + Year + AgeCalc + ReaderExp   + (1|OfficeID1Plus)") )
    

    
#This is the multilevel model, the nAGQ = 0 makes the model run faster but it sligthly less accurate (I have tested that the differences in coefficients between the slower and more accurate model only occurs at the 4th decimal place so these options should be good the optimizer used is also a faster one to use)
m1 <- glmer(formula1,
 data=table2,  na.action = na.omit, family="binomial",
       nAGQ = 0,
    control = glmerControl(optimizer = "nloptwrap", calc.derivs = FALSE, optCtrl = list(maxfun=1000)))

#So I don't have to keep running these models I output the results, this line creates the output file name
outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1", OV, ST, Time,  '.xlsx')

#This gets fit statistics for the models
  fit2df(m1, metrics=TRUE, digits = c(5,5,5), explanatory_name = "Variable") -> t1

#This gets the coefficients and confidence intervals for the model 
ARGH <- broom::tidy(m1, conf.int = TRUE, exponentiate=TRUE, effects="fixed")

#This cleans up the OR table a bit
ARGH$effect <- NULL
ARGH$std.error <- NULL
ARGH$Variable <- ARGH$term
ARGH$term <- NULL
ARGH$estimate <- RRound(ARGH$estimate)
ARGH$p.value <- RRound(ARGH$p.value)
ARGH$conf.low <- RRound(ARGH$conf.low)
ARGH$conf.high <- RRound(ARGH$conf.high)
ARGH$statistic <- NULL
#Creates a p value label to use where smaller pvalues are changed to p <.001
ARGH$PValueLabel <- ifelse(ARGH$p.value < .001, paste0("p<.001"), paste0("p=", ARGH$p.value))
#This creates an overall OR label with the OR and confidence intervals
ARGH$OR <- paste0(ARGH$estimate, " (", ARGH$conf.low, " to ", ARGH$conf.high, ", ", ARGH$PValueLabel, ")")

#Ignoring the intercept here
ARGH <- ARGH %>% dplyr::select(Variable, OR) %>% filter(Variable != "(Intercept)")
 
#Then I output the OR table to one sheet and the model fit stats to the other sheet
    xlsx::write.xlsx(as.data.frame(ARGH), outputfile, sheetName="Sheet1", row.names = FALSE)
    xlsx::write.xlsx(as.data.frame(t1[2]), outputfile, sheetName="Sheet2", append=TRUE, row.names = FALSE)

    #clean up and remove
        rm(m1)
        invisible(gc())

#         #No longer doing formula 2 here
#         m2 <- glmer(formula2,
#  data=table2,  na.action = na.omit, family="binomial",
#        nAGQ = 0,
#     control = glmerControl(optimizer = "nloptwrap", calc.derivs = FALSE, optCtrl = list(maxfun=1000)))
# 
# outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M2", OV, ST, Time, '.xlsx')
#   fit2df(m2, metrics=TRUE, digits = c(5,5,5), explanatory_name = "Variable") -> t1
#   
# ARGH <- broom::tidy(m2, conf.int = TRUE, exponentiate=TRUE, effects="fixed")
# ARGH$effect <- NULL
# ARGH$std.error <- NULL
# ARGH$Variable <- ARGH$term
# ARGH$term <- NULL
# ARGH$estimate <- RRound(ARGH$estimate)
# ARGH$p.value <- RRound(ARGH$p.value)
# ARGH$conf.low <- RRound(ARGH$conf.low)
# ARGH$conf.high <- RRound(ARGH$conf.high)
# ARGH$statistic <- NULL
# ARGH$PValueLabel <- ifelse(ARGH$p.value < .001, paste0("p<.001"), paste0("p=", ARGH$p.value))
# ARGH$OR <- paste0(ARGH$estimate, " (", ARGH$conf.low, " to ", ARGH$conf.high, ", ", ARGH$PValueLabel, ")")
# ARGH <- ARGH %>% dplyr::select(Variable, OR) %>% filter(Variable != "(Intercept)")
#   
#     xlsx::write.xlsx(as.data.frame(ARGH), outputfile, sheetName="Sheet1", row.names = FALSE)
#     xlsx::write.xlsx(as.data.frame(t1[2]), outputfile, sheetName="Sheet2", append=TRUE, row.names = FALSE)
# 
# 
#         rm(m2)
# invisible(gc())

}
}
              }
   


  
 


        
```


```{r Screen Models Cleaning, out.width='100%', results = "asis", echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}


#Since the above outputs the model information needed into csv files so the models don't to run everything, this brings those models back in and puts them in a table to print out. This is only for the 1994-1999 cleaning as the appendix has cleaning for the other sensitivity analyses 

#This gets the screen type and screening outcomes we want
ScreenTypeList <- c("Prevalent ", "Incident")
OutcomeVariables <- c("Recall", "FalsePositiveRecall", "Cancer", "Cancer2", "IntervalCancer", "IntervalCancer1Y",  "NextCancer")

#Using this creates a list with just the Years subset
  #TimeRange <- c("Years", "Year", "Four", "Two", "Year ST Centres", "2080 Exclude 1", "2080 Exclude 2")
  TimeRange <- c("Years")


#The loop
   for(Time in TimeRange){
for (OV in OutcomeVariables) {
for (ST in ScreenTypeList) {

#This gets the file name from the loop variables above
outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1", OV, ST, Time, '.xlsx')
     modeltable <- xlsx::read.xlsx(outputfile, sheetName="Sheet1")
    modelfootnote <- xlsx::read.xlsx(outputfile, sheetName="Sheet2")

#This adds in more detail to the main OR table with some of the model information such as sample size    
    modeltable[nrow(modeltable) + 1,]  <- c("N", str_match(modelfootnote, "Number in model =\\s*(.*?)\\s*,")[2])

 #This puts the screen type into the column name   
 colnames(modeltable)[colnames(modeltable) == "OR"] = paste0(ST)

 #This puts the model table as an object
  assign(  paste("modeltable", OV, ST, Time, sep = ""), modeltable )

} } }


#Another loop for cleaning   
       for(Time in TimeRange){
         
         #Blank dataframe within each time range
         modeltableout <- NULL
         
for (OV in OutcomeVariables) {

  #Get the prevalent model
 modeltablePrevalent  <-  mget(paste0("modeltable", OV, "Prevalent ", Time))
 modeltablePrevalent  <- modeltablePrevalent [[1]]
 
 #Get the incident model
  modeltableIncident <-  mget(paste0("modeltable", OV, "Incident", Time))
 modeltableIncident <- modeltableIncident[[1]]
 
 
#Join the  models
modeltable <- merge(x=modeltablePrevalent , y=modeltableIncident,by="Variable", all.x=TRUE)


#Clean up names and reorder
modeltable$Variable <- ifelse(modeltable$Variable == "as.factor(Group)One reader", "One reader",
                              
                              ifelse(modeltable$Variable == 'relevel(as.factor(Group), ref = "One reader")More than one reader', "Two reader",
                        ifelse(modeltable$Variable == "as.factor(Group)One reader:Threshold500P", "One reader*Log(Threshold)",
                         ifelse(modeltable$Variable == "Threshold500P", "Log(Threshold)",  
                              ifelse(modeltable$Variable == "ReaderExp", "Reader Experience", 
                            ifelse(modeltable$Variable == "AgeCalc", "Age",     
                        
                                modeltable$Variable   ))))))


modeltable$Variable  <- factor(modeltable$Variable, levels=c("Age", "Year", "Reader Experience", "One reader", "Two reader", "N", "Groups", "AIC", "C-statistics"))

modeltable <- modeltable %>% arrange(Variable)



#Can rename OV here if needed to make it cleaner
OVLabel <- ifelse(OV == "FalsePositiveRecall", "False Positive Recall",
            ifelse(OV == "IntervalCancer", "Interval Cancer",     
             ifelse(OV == "NextCancer", "Next Cancer", OV
                  )))

#Put OVLabel as row I guess
OVLabelList <-c( OVLabel, OVLabel)




#Put prevalent and incident with N
 rowlabel <- c( "", 
       paste0(colnames(modeltable)[2], "N=", prettyNum(modeltable[which(modeltable$Variable=="N"),]$Prevalent,big.mark=",",scientific=FALSE)),
       paste0(colnames(modeltable)[3], " N=", prettyNum(modeltable[which(modeltable$Variable=="N"),]$Incident,big.mark=",",scientific=FALSE))
       )
 

 #Get rid of N column now that N is in the column names above
 modeltable <- modeltable %>% filter(Variable != "N")

#Join the row label dataframe with the other dataframe
modeltable <- rbind(rowlabel, modeltable)
modeltable <- rbind(OVLabelList, modeltable)

#Join with the overall dataframe
modeltableout <- rbind(modeltableout, modeltable)

#clean up
rm(modeltable)

} 
         
#After each timepoint prints the table related to the model         
  
           flextable_to_rmd(flextable(modeltableout) %>%   set_caption(caption = paste0("Table ", tablenum, ": Screening Outcomes ", " / Time: " , Time)) %>% add_footer_lines("Results show Odd's Ratio and 95% confidence intervals. A logistic multilevel model was used. For prevalent screenings the group measure shows the number of centres while for incident screenings the group measure shows the unique number of women/number of centres.")   %>% autofit())

#Ups the table numbers
       tablenum <- tablenum + 1
         
         
         }


        
```



```{r Cancer Model Analysis, out.width='100%', results = "asis", eval = FALSE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}


#This does the analysis but on cancer characteristics as the outcome, because these models are faster as it is only on cancers detected by screens and seeing if cancers detected by one reader screens vary from cancers detected by two reader screens I don't really need to output the models as csv but I do anyway



#This is largely the same import and cleaning used as before, this one doesn't look at different time dataset though because there would be a lot less cancers at some of these other time points so this is only done on the main time period (1994-1999)
  creadlist <- c("PATIENTID", "FirstScreenID", "LastAgeOffered", "LastOfferEpisode")
table0 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\Table0.fst", columns = creadlist)

   creadlist <- c( "EPISODEID", "PATIENTID", "OfficeID", "CANCEROUTCOMEFLAG", "dateoffirstofferedappointmentcalc",  "AgeCalc", "Screened", "screeningdate", "datetaken")
    readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst"
table2 <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)
exclusion <- read.csv("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\episodeexcludelist.csv")

table2$Year <- lubridate::year(table2$dateoffirstofferedappointmentcalc)

#This gets this datasample for the cancer analysis
table2 <- table2 %>% filter(EPISODEID %notin% exclusion$EPISODEID & Year > 1993 & Year < 2000 & CANCEROUTCOMEFLAG == "Y" & Screened == 1)

    table2$LastAgeOffered = table0$LastAgeOffered[match(table2$PATIENTID, table0$PATIENTID)]

table2$ScreenTypeLast <- ifelse(table2$EPISODEID %in% table0$FirstScreenID, "Prevalent ",
                      ifelse(table2$EPISODEID %in% table0$LastOfferEpisode & table2$LastAgeOffered > 61, "Last",   "Incident"    ))

table2$ScreenType <- ifelse(table2$EPISODEID %in% table0$FirstScreenID, "Prevalent",   "Incident"    )

rm(table0)
rm(exclusion)


  readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst"
 creadlist <- c("EPISODEID",  "ReaderNum4")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2$ReaderNum4 = table2a$ReaderNum4[match(table2$EPISODEID, table2a$EPISODEID)]
 rm(table2a)
 
 
    creadlist <- c( "EPISODEID",  "screeningdate", "datetaken")
    readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoined.fst"
table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2$screeningdate = table2a$screeningdate[match(table2$EPISODEID, table2a$EPISODEID)]
     table2$datetaken = table2a$datetaken[match(table2$EPISODEID, table2a$EPISODEID)]
     
      rm(table2a)

      


 table2$Group <- ifelse(table2$ReaderNum4 == 1, "One reader", ifelse(table2$ReaderNum4 > 1, "More than one reader", NA))

  readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2recalljoinedpairs.fst"
 creadlist <- c("EPISODEID",  "RecallAllCountF1", "RecallAllCountF2")
 table2a <- read.fst(readlink, from = fromnum, to = tonum, columns = creadlist)
 
table2a <- table2a %>% rowwise() %>% mutate(ReaderExp=mean(c(RecallAllCountF1, RecallAllCountF2), na.rm=T)) 

      table2$ReaderExp = table2a$ReaderExp[match(table2$EPISODEID, table2a$EPISODEID)]
         table2$ReaderExp <- table2$ReaderExp/10000

         
 rm(table2a)
 
 table2$OfficeID1Plus <- ifelse(table2$OfficeID == "S032", "S006",
                          ifelse(table2$OfficeID == "S050", "S009",
                              ifelse(table2$OfficeID == "S077", "S079",
                                  ifelse(table2$OfficeID == "S078", "S071",
                                    ifelse(table2$OfficeID == "S081", "S071",
                                        ifelse(table2$OfficeID == "S083", "S021",
                                          ifelse(table2$OfficeID == "S084", "S079",
                                              ifelse(table2$OfficeID == "S027", "S023",
                                                  ifelse(table2$OfficeID == "S061", "S015",
                                                      ifelse(table2$OfficeID == "S007", "S074", table2$OfficeID
                                                              ))))))))))

#Reading in cancer table here, a bit more cleaning in this part than previous since we are looking at cancer characteristics now
 table4 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table4.fst")
 
            table4$Type <- ifelse(table4$SDDCISInvasive == 1, 0,
                                ifelse(table4$SDDCISInvasive == 2, 1, NA))
            
      table4$InvasiveType <- ifelse(table4$MORPH_CODED == "8520" & table4$BEHAVIOUR_CODED == "3" & table4$Type == 1, 0,
              ifelse(table4$MORPH_CODED == "8500" & table4$BEHAVIOUR_CODED == "3" & table4$Type == 1, 1, NA))
      
      table4$Size <- ifelse(!is.na(table4$SDDCISSize), table4$SDDCISSize,
                            ifelse(!is.na(table4$SDDCISInvasive), table4$SDDCISInvasive, NA))
            
table4$Stage <- factor(table4$Stage, levels = c( "1", "2", "3", "4"))
table4$TStage <- ifelse(table4$`T Stage` == "Missing", NA, table4$`T Stage` )
table4$NStage <- ifelse(table4$`N Stage` == "Missing", NA, 
                  ifelse(table4$`N Stage` == "Nodes involved, unclear extent", NA, 
                        table4$`N Stage` ))
table4$MStage <- ifelse(table4$`M Stage` == "Missing", NA, table4$`M Stage` )

table4$HormonalStatus <- ifelse(table4$ER_STATUS == "P" & table4$HER2_STATUS == "N", 1,
                          ifelse(table4$ER_STATUS == "" | table4$HER2_STATUS == "", NA, 0     ))






  table4$IDScreen <- paste0(table4$PSEUDO_PERSONID, "-", table4$screeningdate)
    table4$IDDate<- paste0(table4$PSEUDO_PERSONID, "-", table4$DIAGNOSISDATEBEST)
    
    table4$SDInvasiveGrade2 <- factor(table4$SDInvasiveGrade, levels = c("G3", "G2", "G1", "GX", "Other", "Miscode", "Missing", "DCIS"))
    table4$SDDCISGrade2 <- factor(table4$SDDCISGrade, levels = c("GH", "GI", "GL", "GX", "Other", "Miscode", "Missing", "Invasive"))

    
  table4sub <- table4 




 table4sub <- table4sub   %>%  group_by(EPISODEIDLink)  %>% arrange(EPISODEIDLink,  desc(ScreenedTumor), desc(SDDCISInvasive), SDInvasiveGrade2, SDDCISGrade2, desc(SDInvasiveSize), desc(SDDCISSize), ClosestDays, PSEUDO_TUMOURID)
table4sub <-  table4sub[!duplicated(table4sub$EPISODEIDLink),]



table2$DIAGNOSISDATEBEST = table4sub$DIAGNOSISDATEBEST[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
   table2$EPISODEIDLink = table4sub$EPISODEIDLink[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
    table2$ClosestDays = table4sub$ClosestDays[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
      table2$ScreenedTumor = table4sub$ScreenedTumor[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
       table2$Type = table4sub$Type[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
       table2$InvasiveType = table4sub$InvasiveType[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$Size = table4sub$Size[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$Stage = table4sub$Stage[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$TStage = table4sub$TStage[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$NStage = table4sub$NStage[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$MStage = table4sub$MStage[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$HormonalStatus = table4sub$HormonalStatus[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
#table2$Screened = table4sub$Screened[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$ScreenedTumor = table4sub$ScreenedTumor[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$MaxScreened = table4sub$MaxScreened[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$SDNumberOfNodes1 = table4sub$SDNumberOfNodes1[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$SDInvasiveSize = table4sub$SDInvasiveSize[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$SDDCISSize = table4sub$SDDCISSize[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$NPI = table4sub$NPI[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$SDInvasiveGrade2 = table4sub$SDInvasiveGrade2[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$SDDCISGrade2 = table4sub$SDDCISGrade2[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$SDInvasiveGrade = table4sub$SDInvasiveGrade2[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$SDDCISGrade = table4sub$SDDCISGrade2[match(table2$EPISODEID, table4sub$EPISODEIDLink)]
table2$GRADE = table4sub$GRADE[match(table2$EPISODEID, table4sub$EPISODEIDLink)]


#Make sure the ordinal variables have factors in right order

table2$TStage <- as.factor(table2$TStage)
table2$NStage <- as.factor(table2$NStage)
table2$SDNumberOfNodes1 <- as.factor(table2$SDNumberOfNodes1)


#Read in next invite days
daysnext   <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\daysbetweeninvite2.fst")
table2$NextInviteDays = daysnext$NextInviteDays[match(table2$EPISODEID, daysnext$EPISODEID)]

#Ignoring screens with no reader group
table2 <- table2 %>% filter(!is.na(Group))

#Make ordinal binary here
table2$StageNum <- ifelse(table2$Stage == "1", 0, ifelse(table2$Stage %in% c("2", "3", "4"), 1, NA))
table2$TStageNum <- ifelse(table2$TStage == "1", 0, ifelse(table2$TStage %in% c("2", "3", "4"), 1, NA))
table2$NStageNum <- ifelse(table2$NStage == "0", 0, ifelse(table2$NStage %in% c("2", "3", "1"), 1, NA))
table2$SDNumberOfNodes1Num <- ifelse(table2$SDNumberOfNodes1 == "0", 0, ifelse(table2$SDNumberOfNodes1 %in% c("2", "1"), 1, NA))
table2$DCISGradeNum <- ifelse(table2$SDDCISGrade2 == "GL", 0, ifelse(table2$SDDCISGrade2 %in% c("GI", "GH"), 1, NA))
table2$InvasiveGradeNum <- ifelse(table2$SDInvasiveGrade2 == "G1", 0, ifelse(table2$SDInvasiveGrade2 %in% c("G2", "G3"), 1, NA))


#Better labels
    table2$SDInvasiveGrade2 <- ifelse(table2$GRADE == "G1", "G1",
                     ifelse(table2$GRADE == "G2", "G2",    
                              ifelse(table2$GRADE == "G3", "G3", 
                                      ifelse(table2$GRADE == "G4", "G3",
                                              ifelse(table2$GRADE == "GX", "Other",
                                                     ifelse(table2$GRADE == "GH", "Other",
                     ifelse(table2$GRADE == "GI", "Other",    
                              ifelse(table2$GRADE == "GL", "Other", 
                                 ifelse(table2$GRADE == "" | is.na(table2$GRADE ), "Missing", "Other")))))))))

table2$SDDCISGrade2 <- ifelse(table2$GRADE == "GH", "High",
                     ifelse(table2$GRADE == "GI", "Intermediate",    
                              ifelse(table2$GRADE == "GL", "Low", 
                                      ifelse(table2$GRADE == "GX", "Other", 
                                             ifelse(table2$GRADE == "G1", "Other",
                     ifelse(table2$GRADE == "G2", "Other",    
                              ifelse(table2$GRADE == "G3", "Other", 
                                      ifelse(table2$GRADE == "G4", "Other",
                                 ifelse(table2$GRADE == "" | is.na(table2$GRADE ), "Missing", "Other")))))))))

#Above cancers can be linked to screens that did not detect a cancer (so interval cancers for instance) so we are filtering to screens were a cancer was detected, this is mainly to look at missingness of cancer characteristics, also got to filter for screened tumors (duh)
    CancerScreened <-table2 %>% filter(CANCEROUTCOMEFLAG == "Y" & ScreenedTumor == 1)
    
    
  
    
    #Do a table here exploring missingness of the cancer characteristics and if missingness is due to linkage or the registry
    CancerSubset <- table2 %>% filter(CANCEROUTCOMEFLAG == "Y" & ScreenedTumor == 1) %>% dplyr::select(ScreenType, Group, "Type", "InvasiveType", "InvasiveGradeNum", "SDInvasiveGrade",  "SDInvasiveGrade2", "DCISGradeNum","SDDCISGrade", "SDDCISGrade2", "MStage", "Size", "SDInvasiveSize", "SDDCISSize", "NPI", "StageNum", "Stage", "TStageNum", "TStage", "NStageNum", "NStage", "SDNumberOfNodes1Num", "SDNumberOfNodes1")
    

    CancerSubset %>%
  mutate(across(.cols = -Type, .fns = is.na)) %>%
  # then createa summary table tabulating missing data rates
  tbl_summary(by = Type, digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2))) %>%
  modify_caption("Missing Data Counts") %>%
  as_kable()
    
    
    #Changing variables to run further descriptives for cancer
    CancerSubset$SDInvasiveSize <- as.numeric(CancerSubset$SDInvasiveSize)
    CancerSubset$Size <- as.numeric(CancerSubset$Size)
    CancerSubset$SDDCISSize <- as.numeric(CancerSubset$SDDCISSize)
  
    #Descriptive tables for prevalent and incident screens which detected a cancer  
    screentable1 <- CancerSubset %>% filter(ScreenType == "Prevalent") %>%  dplyr::select(Group, "Type", "InvasiveType", "SDInvasiveGrade2", "SDDCISGrade2",  "SDInvasiveGrade", "SDDCISGrade", "MStage", "Size", "SDInvasiveSize", "SDDCISSize", "NPI", "Stage", "TStage", "NStage", "SDNumberOfNodes1") %>%
  tbl_summary(by = Group, digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2))) %>%
   bold_labels()

screentable2 <-  CancerSubset %>% filter(ScreenType == "Incident") %>%  dplyr::select(Group, "Type", "InvasiveType", "SDInvasiveGrade2", "SDDCISGrade2", "SDInvasiveGrade", "SDDCISGrade", "MStage", "Size", "SDInvasiveSize", "SDDCISSize", "NPI", "Stage", "TStage", "NStage", "SDNumberOfNodes1") %>%
  tbl_summary(by = Group, digits = list(everything() ~ RRound, all_categorical() ~ c(0, RRound2))) %>%
   bold_labels()

#Printing cancer descriptive table
print("Cancer differences First two columns are prevalent, last two are incident, can't figure out how to add spanning header")
 print(tbl_merge(
    tbls = list(screentable1, screentable2),
    tab_spanner = c("**Prevalent**", "**Incident**")))
 
 
    
      rm(table4) 
    
   
 #Because there are numerical variables in here we can't just loop them through the same model, we were originally trying to get ordinal analysis to work but because of the limited data of the cancer registry in the earlier years it was hard to get enough of certain cancers in certain centres so even though these are listed under ordinal the mode was turned to numerical, the way we have three things looping I still kept these three categories even though the analysis was either binary or numerical outcomes NOT ordinal outcomes and some variables (Like overall size) was not actually looked at, just needed a space filler to keep categories even
Binary <- c("Type", "InvasiveType", "InvasiveGradeNum", "MStage")
Numerical <- c("Size", "SDInvasiveSize", "SDDCISSize", "NPI")
Ordinal <- c("StageNum", "TStageNum", "NStageNum", "SDNumberOfNodes1Num")
dfloop <- as.data.frame(cbind(Binary, Numerical, Ordinal))



#This is just a list of the one cancer table, then a list of prevalent and incident screens
table2type <- list(CancerScreened)
ScreenTypeList <- c("Prevalent", "Incident")


#saving back up table just in case I need to read things in again without joining all the tables
table2bu <- table2

#Time range is just the one but left loop format just in case
 TimeRange <- c("Years")

 #Loop

    for(Time in TimeRange){
      
for(T2Type in table2type){
  
  for (ST in ScreenTypeList) {

  #I put the variables into sets of threes to loop through in order to have some be logistic models and others linear
for(i in 1:nrow(dfloop)) {      
  
  
#Much of the code here is similar to the screening models code
  table2 <- T2Type
  
  Epilist <- SubsetList %>% filter(Subset %in% Time)
           
           table2 <- table2 %>% filter(EPISODEID %in% Epilist$EPISODEID)
           
     tabletype <- "Screened"
     
#Here I create the two tables sets
Prevalent  <- table2 %>% filter(ScreenType == "Prevalent")
Incident <- table2 %>% filter(ScreenType != "Prevalent")

#Then depending on which screen type we are looking at assign either prevalent or incident screens to table2
invisible(ifelse(ST == "Prevalent", table2 <- Prevalent , ifelse(ST == "Incident", table2 <- Incident,  NA)))

#Get the name of the three outcomes
  OV1 <- dfloop[i,1]
  OV2 <- dfloop[i,2]
  OV3 <- dfloop[i,3]
   
  
   #This is a binary formula
  formula1 <- paste0("as.numeric(", OV1, ") ~ relevel(as.factor(Group), ref = 'One reader') + ReaderExp +  Year + AgeCalc   + (1|OfficeID1Plus)")

m1 <- glmer(formula1,
 data=table2,  na.action = na.omit, family="binomial",
       nAGQ = 0,
    control = glmerControl(optimizer = "nloptwrap", calc.derivs = FALSE, optCtrl = list(maxfun=1000)))


outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1", tabletype, OV1, ST, Time, '.xlsx')
  fit2df(m1, metrics=TRUE, digits = c(5,5,5), explanatory_name = "Variable") -> t1
ARGH <- broom::tidy(m1, conf.int = TRUE, exponentiate=TRUE, effects="fixed")
ARGH$effect <- NULL
ARGH$std.error <- NULL
ARGH$Variable <- ARGH$term
ARGH$term <- NULL
ARGH$estimate <- RRound(ARGH$estimate)
ARGH$p.value <- RRound(ARGH$p.value)
ARGH$conf.low <- RRound(ARGH$conf.low)
ARGH$conf.high <- RRound(ARGH$conf.high)
ARGH$statistic <- NULL
ARGH$PValueLabel <- ifelse(ARGH$p.value < .001, paste0("p<.001"), paste0("p=", ARGH$p.value))
ARGH$OR <- paste0(ARGH$estimate, " (", ARGH$conf.low, " to ", ARGH$conf.high, ", ", ARGH$PValueLabel, ")")
ARGH <- ARGH %>% dplyr::select(Variable, OR) %>% filter(Variable != "(Intercept)")
  
    xlsx::write.xlsx(as.data.frame(ARGH), outputfile, sheetName="Sheet1", row.names = FALSE)
  xlsx::write.xlsx(as.data.frame(t1[2]), outputfile, sheetName="Sheet2", append=TRUE, row.names = FALSE)
  

rm(m1)
rm(m2)
rm(formula1)
rm(formula2)

#Numerical formula
  formula1 <- paste0("as.numeric(", OV2, ") ~ relevel(as.factor(Group), ref = 'One reader') + ReaderExp + Year + AgeCalc   + (1|OfficeID1Plus)")

m1 <- lmer(formula1,
 data=table2,  na.action = na.omit,     # nAGQ = 0,
    control = lmerControl(optimizer = "nloptwrap", calc.derivs = FALSE, optCtrl = list(maxfun=1000)))

outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1", tabletype, OV2, ST, Time, '.xlsx')
  fit2df(m1, metrics=TRUE, digits = c(5,5,5), explanatory_name = "Variable") -> t1
  
ARGH <- broom::tidy(m1, conf.int = TRUE, exponentiate=FALSE, effects="fixed")
ARGH$effect <- NULL
ARGH$std.error <- NULL
ARGH$Variable <- ARGH$term
ARGH$term <- NULL
ARGH$estimate <- RRound(ARGH$estimate)
ARGH$p.value <- RRound(ARGH$p.value)
ARGH$conf.low <- RRound(ARGH$conf.low)
ARGH$conf.high <- RRound(ARGH$conf.high)
ARGH$statistic <- NULL
ARGH$PValueLabel <- ifelse(ARGH$p.value < .001, paste0("p<.001"), paste0("p=", ARGH$p.value))
ARGH$OR <- paste0(ARGH$estimate, " (", ARGH$conf.low, " to ", ARGH$conf.high, ", ", ARGH$PValueLabel, ")")
ARGH <- ARGH %>% dplyr::select(Variable, OR) %>% filter(Variable != "(Intercept)")
  
    xlsx::write.xlsx(as.data.frame(ARGH), outputfile, sheetName="Sheet1", row.names = FALSE)
  xlsx::write.xlsx(as.data.frame(t1[2]), outputfile, sheetName="Sheet2", append=TRUE, row.names = FALSE)

rm(m1)
rm(m2)
rm(formula1)
rm(formula2)


#Here are the rements of the ordinal analysis that is no longer being used
#Stupid ordinal formulas changing this to binary
#   formula1 <- paste0("as.factor(", OV3, ") ~ as.factor(Group)  + scale(Year) + scale(AgeCalc) ")
#  formula2 <- paste0("as.factor(", OV3, ") ~ Threshold500P  + scale(Year) + scale(AgeCalc)  ")
#     
# m1 <- clm(formula1  ,
#   data=subset(table2),  na.action = na.omit,   nAGQ = 0,
# link = "probit", threshold = "equidistant")
# m1sum <- summary(m1)
# 
# outputfile <- paste0('C:\\Users\\morrisbz\\Desktop\\UGH\\Models\\', "DOVT1M1", tabletype, OV3, ST, Time,  '.xlsx')
# t1a <- as.data.frame(round(m1sum$coefficients,3))
# t1a1 <- as.data.frame(round(exp(confint(m1, level = 0.95)), 3))
# # new merge
# t1a <- merge(t1a, t1a1, 
#                           by = 'row.names', all = TRUE) 
# #t1a <- cbind(t1a, t1a1)
# t1a$OR <- round(exp(t1a$Estimate), 3)
# t1a$Coefficient <- paste0(t1a$OR, " (", t1a$`2.5 %`, "-", t1a$`97.5 %`, ", p=", t1a$`Pr(>|z|)`, ")")
# t1a$Variable <- t1a$Row.names
# t1a <- t1a %>% dplyr::select(Variable, Coefficient)
# xlsx::write.xlsx(t1a, outputfile, sheetName="Sheet1", row.names = FALSE)
# 
# #Then need number in model
# t1b1 <- as.data.frame(m1$dims)
# t1bpaste1 <- paste0("Number in model = ", m1sum$nobs, ", ")
# t1bpaste2 <- paste0("Number of groups = ", t1b1$nlev.gf, ", ")
# t1bpaste3 <- paste0("Log likelihood = ", m1$logLik, ", ")
# t1bpaste4 <- paste0("AIC = ", m1$info$AIC)
# t1bpaste <- paste0(t1bpaste1, t1bpaste2, t1bpaste3, t1bpaste4)
# xlsx::write.xlsx(t1bpaste, outputfile, sheetName="Sheet2", append=TRUE,  row.names = FALSE)
# 
# 
# rm(t1a, t1a1, t1b1, t1bpaste, t1bpaste1, t1bpaste2, t1bpaste3, t1bpaste4)
# 
# m2 <- clm(formula2  ,
#   data=subset(table2),  na.action = na.omit,   nAGQ = 0,
# link = "probit", threshold = "equidistant")
# m2sum <- summary(m2)
# 
# outputfile <- paste0('C:\\Users\\morrisbz\\Desktop\\UGH\\Models\\', "DOVT1M2", tabletype, OV3, ST, Time,  '.xlsx')
# t1a <- as.data.frame(round(m2sum$coefficients,3))
# t1a1 <- as.data.frame(round(exp(confint(m2, level = 0.95)), 3))
# # new merge
# t1a <- merge(t1a, t1a1, 
#                           by = 'row.names', all = TRUE) 
# #t1a <- cbind(t1a, t1a1)
# t1a$OR <- round(exp(t1a$Estimate), 3)
# t1a$Coefficient <- paste0(t1a$OR, " (", t1a$`2.5 %`, "-", t1a$`97.5 %`, ", p=", t1a$`Pr(>|z|)`, ")")
# t1a$Variable <- t1a$Row.names
# t1a <- t1a %>% dplyr::select(Variable, Coefficient)
# xlsx::write.xlsx(t1a, outputfile, sheetName="Sheet1", row.names = FALSE)
# 
# #Then need number in model
# t1b1 <- as.data.frame(m2$dims)
# t1bpaste1 <- paste0("Number in model = ", m2sum$nobs, ", ")
# t1bpaste2 <- paste0("Number of groups = ", t1b1$nlev.gf, ", ")
# t1bpaste3 <- paste0("Log likelihood = ", m1$logLik, ", ")
# t1bpaste4 <- paste0("AIC = ", m1$info$AIC)
# t1bpaste <- paste0(t1bpaste1, t1bpaste2, t1bpaste3, t1bpaste4)
# xlsx::write.xlsx(t1bpaste, outputfile, sheetName="Sheet2", append=TRUE,  row.names = FALSE)

 
  #This is  binary formula being used for ordinal variables that have been changed to binary instead
  formula1 <- paste0("as.numeric(", OV3, ") ~ relevel(as.factor(Group), ref = 'One reader') + ReaderExp  + Year + AgeCalc   + (1|OfficeID1Plus)")

m1 <- glmer(formula1,
 data=table2,  na.action = na.omit, family="binomial",
       nAGQ = 0,
    control = glmerControl(optimizer = "nloptwrap", calc.derivs = FALSE, optCtrl = list(maxfun=1000)))

outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1", tabletype, OV3, ST, Time, '.xlsx')
  fit2df(m1, metrics=TRUE, digits = c(5,5,5), explanatory_name = "Variable") -> t1
ARGH <- broom::tidy(m1, conf.int = TRUE, exponentiate=TRUE, effects="fixed")
ARGH$effect <- NULL
ARGH$std.error <- NULL
ARGH$Variable <- ARGH$term
ARGH$term <- NULL
ARGH$estimate <- RRound(ARGH$estimate)
ARGH$p.value <- RRound(ARGH$p.value)
ARGH$conf.low <- RRound(ARGH$conf.low)
ARGH$conf.high <- RRound(ARGH$conf.high)
ARGH$statistic <- NULL
ARGH$PValueLabel <- ifelse(ARGH$p.value < .001, paste0("p<.001"), paste0("p=", ARGH$p.value))
ARGH$OR <- paste0(ARGH$estimate, " (", ARGH$conf.low, " to ", ARGH$conf.high, ", ", ARGH$PValueLabel, ")")
ARGH <- ARGH %>% dplyr::select(Variable, OR) %>% filter(Variable != "(Intercept)")
  
    xlsx::write.xlsx(as.data.frame(ARGH), outputfile, sheetName="Sheet1", row.names = FALSE)
  xlsx::write.xlsx(as.data.frame(t1[2]), outputfile, sheetName="Sheet2", append=TRUE, row.names = FALSE)


rm(m1)
rm(m2)
rm(formula1)
rm(formula2)

}

  }
  
} }


        
```


Make tables from model output

```{r Cancer Model Cleaning, out.width='100%', results = "asis", echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE, fig.align="center"}

#This is similar to the screening cleaning code, where the csv models that were outputted are read back in again


Binary <- c("Type", "InvasiveType", "InvasiveGradeNum", "MStage")
Numerical <- c("Size", "SDInvasiveSize", "SDDCISSize", "NPI")
Ordinal <- c("StageNum", "TStageNum", "NStageNum", "SDNumberOfNodes1Num")
dfloop <- as.data.frame(cbind(Binary, Numerical, Ordinal))

table2type <- c("Screened")
ScreenTypeList <- c("Prevalent", "Incident")

 TimeRange <- c("Years")
  

   for(Time in TimeRange){


for(T2Type in table2type){
  
  for (ST in ScreenTypeList) {

for(i in 1:nrow(dfloop)) {       

  OV1 <- dfloop[i,1]
  OV2 <- dfloop[i,2]
  OV3 <- dfloop[i,3]
  
  #OV1
    outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1", T2Type, OV1, ST, Time, '.xlsx')
       modeltable <- xlsx::read.xlsx(outputfile, sheetName="Sheet1")
    modelfootnote <- xlsx::read.xlsx(outputfile, sheetName="Sheet2")
    
    modeltable[nrow(modeltable) + 1,]  <- c("N", str_match(modelfootnote, "Number in model =\\s*(.*?)\\s*,")[2])
    modeltable[nrow(modeltable) + 1,]  <- c("Groups", str_match(modelfootnote, "Number of groups =\\s*(.*?)\\s*,")[2])
    modeltable[nrow(modeltable) + 1,]  <- c("AIC", str_match(modelfootnote, "AIC =\\s*(.*?)\\s*,")[2])
    modeltable[nrow(modeltable) + 1,]  <- c("C-statistics", sub('.*C-statistic = ', '', modelfootnote))
    
colnames(modeltable)[colnames(modeltable) == "OR"] = paste0(ST)

 assign(  paste("modeltable", T2Type, OV1, ST,   Time, sep = ""), modeltable )
 
 rm(modeltable)
 rm(modelfootnote)
  
  # OV2
    outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1", T2Type, OV2, ST,  Time, '.xlsx')
       modeltable <- xlsx::read.xlsx(outputfile, sheetName="Sheet1")
    modelfootnote <- xlsx::read.xlsx(outputfile, sheetName="Sheet2")
    
    modeltable[nrow(modeltable) + 1,]  <- c("N", str_match(modelfootnote, "Number in model =\\s*(.*?)\\s*,")[2])
    modeltable[nrow(modeltable) + 1,]  <- c("Groups", str_match(modelfootnote, "Number of groups =\\s*(.*?)\\s*,")[2])
    modeltable[nrow(modeltable) + 1,]  <- c("Log likelihood", str_match(modelfootnote, "Log likelihood =\\s*(.*?)\\s*,")[2])
    modeltable[nrow(modeltable) + 1,]  <- c("REML", sub('.*REML criterion = ', '', modelfootnote))
    
colnames(modeltable)[colnames(modeltable) == "Coefficient"] = paste0(ST)


 assign(  paste("modeltable", T2Type, OV2, ST,   Time, sep = ""), modeltable )
 
  rm(modeltable)
 rm(modelfootnote)
  

 #OV3 binary

    outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1", T2Type, OV3, ST, Time, '.xlsx')
       modeltable <- xlsx::read.xlsx(outputfile, sheetName="Sheet1")
    modelfootnote <- xlsx::read.xlsx(outputfile, sheetName="Sheet2")
    
    modeltable[nrow(modeltable) + 1,]  <- c("N", str_match(modelfootnote, "Number in model =\\s*(.*?)\\s*,")[2])
    modeltable[nrow(modeltable) + 1,]  <- c("Groups", str_match(modelfootnote, "Number of groups =\\s*(.*?)\\s*,")[2])
    modeltable[nrow(modeltable) + 1,]  <- c("AIC", str_match(modelfootnote, "AIC =\\s*(.*?)\\s*,")[2])
    modeltable[nrow(modeltable) + 1,]  <- c("C-statistics", sub('.*C-statistic = ', '', modelfootnote))
    
colnames(modeltable)[colnames(modeltable) == "OR"] = paste0(ST)


 assign(  paste("modeltable", T2Type, OV3, ST,   Time, sep = ""), modeltable )
 
 rm(modeltable)
 rm(modelfootnote)

}

  }
  
} }


 
 OutcomeVariables <- c("Type", "InvasiveGradeNum",  "InvasiveType", "Size", "SDInvasiveSize", "SDDCISSize", "StageNum", "TStageNum", "NStageNum", "MStage", "SDNumberOfNodes1Num",  "NPI")

       for(Time in TimeRange){
         
         modeltableout <- NULL
         
for (OV in OutcomeVariables) {
  
  for(T2Type in table2type){

 modeltablePrevalent  <-  mget(paste0("modeltable", T2Type,  OV, "Prevalent",  Time))
 modeltablePrevalent  <- modeltablePrevalent [[1]]
 colnames(modeltablePrevalent) <- c("Variable", "Prevalent")
 
 
  modeltableIncident <-  mget(paste0("modeltable", T2Type, OV,  "Incident",   Time))
 modeltableIncident <- modeltableIncident[[1]]
  colnames(modeltableIncident) <- c("Variable", "Incident")

 

 
#Join the three models
modeltable <- merge(x=modeltablePrevalent , y=modeltableIncident,by="Variable", all.x=TRUE)


#Clean up names and reorder
modeltable$Variable <- ifelse(modeltable$Variable == "as.factor(Group)One reader", "One reader",
                              
                              ifelse(modeltable$Variable == 'relevel(as.factor(Group), ref = "One reader")More than one reader', "Two reader",
                        ifelse(modeltable$Variable == "as.factor(Group)One reader:Threshold500P", "One reader*Log(Threshold)",
                         ifelse(modeltable$Variable == "Threshold500P", "Log(Threshold)",  
                              ifelse(modeltable$Variable == "ReaderExp", "Reader Experience", 
                            ifelse(modeltable$Variable == "AgeCalc", "Age",     
                        
                                modeltable$Variable   ))))))


modeltable$Variable  <- factor(modeltable$Variable, levels=c("Age", "Year", "Reader Experience", "One reader", "Two reader", "N", "Groups", "AIC", "C-statistics"))

modeltable <- modeltable %>% arrange(Variable)




#Can rename OV here if needed to make it cleaner  
OVLabel <- ifelse(OV == "Type", "Invasive Cancer (vs DCIS)",
            ifelse(OV == "InvasiveType", "Invasive ductal carcinoma (vs invasive lobular carcinoma)",     
            ifelse(OV == "Size", "Size (mm)",    
            ifelse(OV == "SDInvasiveSize", "Size (mm) invasive cancers",    
            ifelse(OV == "SDDCISSize", "Size (mm) DCIS cancer",
            ifelse(OV == "StageNum", "Stage (2-4 vs 1)",
            ifelse(OV == "TStageNum", "T Stage (2-4 vs 1)",
            ifelse(OV == "NStageNum", "N Stage (1-3 vs 0)",
            ifelse(OV == "MStage", "M Stage 1 (vs 0)",
            ifelse(OV == "InvasiveGradeNum", "Invasive Grade G2/3 (vs G1)",
            ifelse(OV == "DCISGradeNum", "DCIS Grade GI/GH (vs GL)",
            ifelse(OV == "SDNumberOfNodes1Num", "Number of Nodes (1 or more vs 0)",
            ifelse(OV == "HormonalStatus", "Hormonal Status ER+HER2 (vs other combinations)", OV)))))))))))))




T2TypeLabel <- ifelse(T2Type == "All", "Screened and Interval Cancers", "Screened Cancers" )

ModelLabel <- ifelse(OV %in% Binary, "logistic",
                ifelse(OV %in% Numerical, "linear",     
                       ifelse(OV %in% Ordinal, "logistic", NA  
                     )))


#Put OVLabel as row I guess
OVLabelList <-c( OVLabel, OVLabel)

#Put prevalent and incident with N
 rowlabel <- c( "",
       paste0(colnames(modeltable)[2], "N=", prettyNum(modeltable[which(modeltable$Variable=="N"),]$Prevalent,big.mark=",",scientific=FALSE)),
       paste0(colnames(modeltable)[3], " N=", prettyNum(modeltable[which(modeltable$Variable=="N"),]$Incident,big.mark=",",scientific=FALSE))
       )
 

  modeltable <- modeltable %>% filter(Variable != "" )


modeltable <- rbind(rowlabel, modeltable)
modeltable <- rbind(OVLabelList, modeltable)

modeltableout <- rbind(modeltableout, modeltable)


rm(modeltable)

} }
         
   #Prints table      
      flextable_to_rmd(flextable(modeltableout) %>%   set_caption(caption = paste0("Table ", tablenum, ": Screening Outcomes ", " / Time: " , Time)) %>% add_footer_lines("Results show Odd's Ratio and 95% confidence intervals. A logistic multilevel model was used. For prevalent screenings the group measure shows the number of centres while for incident screenings the group measure shows the unique number of women/number of centres.")   %>% autofit())


       tablenum <- tablenum + 1
         
         
         }
 

        
```



Reader number overall effects graph.

```{r Overall Graph for Effect Sizes Reader Number, out.width='100%', results = "asis", echo = FALSE, eval = FALSE, warning = FALSE, message = FALSE, fig.align="center"}



#This code reads in all the main models to create a graph that shows the overall effect for reader number on different screening outcomes and cancer charateristics, this graph isn't used anymore so the code isn't really updated


OutcomeVariables <- c("Recall", "FalsePositiveRecall", "Cancer", "IntervalCancer", "NextCancer")

 SP  <- c( "Type", "InvasiveType", "Size", "SDInvasiveSize", "SDDCISSize", "StageNum", "TStageNum", "NStageNum",   "SDNumberOfNodes1Num",  "NPI",  "MStage", "InvasiveGradeNum")

ScreenTypeList <- c( "Incident")
NotOR <- c( "Size", "SDInvasiveSize", "SDDCISSize", "NPI")


df <- NULL


 TimeRange <- c("Years", "Year", "Four", "Two")
  

   for(Time in TimeRange){
     
for(OV in OutcomeVariables){
  
  for (ST in ScreenTypeList) {
    
    filename <- ifelse(OV %in% SP, paste0("C:\\Users\\u4111872\\Downloads\\UGH\\Models\\","DOVT1M1Screened", OV, ST, Time, ".xlsx"), paste0("C:\\Users\\u4111872\\Downloads\\UGH\\Models\\","DOVT1M1", OV, ST, Time, ".xlsx") )
                       
     modeltable <- xlsx::read.xlsx(filename, sheetName="Sheet1")


     variable <- c(paste0(OV))
     stat <- c(paste0(modeltable[modeltable$Variable == 'relevel(as.factor(Group), ref = "One reader")More than one reader',][,2]))
     ORType <- ifelse(OV %in% NotOR, "Not OR", "OR")
     TimeRange <- Time
     modeltablesave <- data.frame(variable, stat, ORType, TimeRange)
     df <- rbind(df, modeltablesave)
     
    
  }} }

#Get OR and hl and ul from df
df$OR <- str_split_fixed(df$stat, "\\(", 2)[,1]
df$Clean1 <- str_match_all(df$stat, "(?<=\\().+?(?=\\,)")
df$Clean2 <- ifelse(substr(df$Clean1, 1, 1) == "-", sub("^.", "N", df$Clean1), df$Clean1)

df$LB <- str_split_fixed(df$Clean2 , "-", 2)[,1]
df$UB <- str_split_fixed(df$Clean2 , "-", 2)[,2]

df$LB <- gsub("N", "-", df$LB) 
df$OR <- as.numeric(df$OR)
df$LB <- as.numeric(df$LB)
df$UB <- as.numeric(df$UB)

df$OR <- ifelse(df$ORType == "Not OR", exp(df$OR), df$OR)
df$LB <- ifelse(df$ORType == "Not OR", exp(df$LB), df$LB)
df$UB <- ifelse(df$ORType == "Not OR", exp(df$UB), df$UB)



dfIncident <- df


#And first screen

ScreenTypeList <- c( "Prevalent")
NotOR <- c( "Size", "SDInvasiveSize", "SDDCISSize", "NPI")

df <- NULL


 TimeRange <- c("Years", "Year", "Four", "Two")
  

   for(Time in TimeRange){

for(OV in OutcomeVariables){
  
  for (ST in ScreenTypeList) {
    
    filename <- ifelse(OV %in% SP, paste0("C:\\Users\\u4111872\\Downloads\\UGH\\Models\\","DOVT1M1Screened", OV, ST, Time, ".xlsx"), paste0("C:\\Users\\u4111872\\Downloads\\UGH\\Models\\","DOVT1M1Screened", OV, ST, Time, ".xlsx") )
                       
     modeltable <- xlsx::read.xlsx(filename, sheetName="Sheet1")


     variable <- c(paste0(OV))
     stat <- c(paste0(modeltable[modeltable$Variable == 'relevel(as.factor(Group), ref = "One reader")More than one reader',][,2]))
     ORType <- ifelse(OV %in% NotOR, "Not OR", "OR")
     TimeRange <- Time
     modeltablesave <- data.frame(variable, stat, ORType, TimeRange)
     df <- rbind(df, modeltablesave)
     
    
  }} }

df$OR <- str_split_fixed(df$stat, "\\(", 2)[,1]
df$Clean1 <- str_match_all(df$stat, "(?<=\\().+?(?=\\,)")
df$Clean2 <- ifelse(substr(df$Clean1, 1, 1) == "-", sub("^.", "N", df$Clean1), df$Clean1)

df$LB <- str_split_fixed(df$Clean2 , "-", 2)[,1]
df$UB <- str_split_fixed(df$Clean2 , "-", 2)[,2]

df$LB <- gsub("N", "-", df$LB) 
df$OR <- as.numeric(df$OR)
df$LB <- as.numeric(df$LB)
df$UB <- as.numeric(df$UB)

df$OR <- ifelse(df$ORType == "Not OR", exp(df$OR), df$OR)
df$LB <- ifelse(df$ORType == "Not OR", exp(df$LB), df$LB)
df$UB <- ifelse(df$ORType == "Not OR", exp(df$UB), df$UB)



dfPrevalent  <- df



#Make all in one graph
dfIncident$Group <- "Incident"
dfPrevalent$Group <- "Prevalent"


df <- rbind(dfIncident, dfPrevalent )



#Change labeling
df$OVLabel <- ifelse(df$variable == "FalsePositiveRecall", "False Positive Recall",
            ifelse(df$variable == "IntervalCancer", "Interval Cancer",     
             ifelse(df$variable == "NextCancer", "Next Cancer", 
             ifelse(df$variable == "Type", "Invasive Cancer (vs DCIS)",
            ifelse(df$variable == "InvasiveType", "Invasive ductal carcinoma \n (vs invasive lobular carcinoma)",     
            ifelse(df$variable == "Size", "Size (mm)",    
            ifelse(df$variable == "SDInvasiveSize", "Size (mm) invasive cancers",    
            ifelse(df$variable == "SDDCISSize", "Size (mm) DCIS cancer",
            ifelse(df$variable == "StageNum", "Stage (1 vs 2-4)",
            ifelse(df$variable == "TStageNum", "T Stage (1 vs 2-4)",
            ifelse(df$variable == "NStageNum", "N Stage (0 vs 1-3)",
            ifelse(df$variable == "MStage", "M Stage 1 (vs 0)",
            ifelse(df$variable == "InvasiveGradeNum", "Invasive Grade G1 (vs G2-G3)",
            ifelse(df$variable == "SDNumberOfNodes1Num", "Number of Nodes (0 vs more than 0)",
            ifelse(df$variable == "HormonalStatus", "Hormonal Status ER+HER2 (vs other combinations)", df$variable)))))))))))))))


screeninglist <- c("FalsePositiveRecall", "IntervalCancer", "NextCancer", "Recall", "Cancer")
df <- df %>% filter(variable %in% screeninglist)



df$`Screen Type` <- df$Group

library(forcats)

#only the screening outcomes graph

jpeg("C:\\Users\\u4111872\\Downloads\\UGH\\graphs\\effectsizereadernumberplottimerange235.png", width = 3200, height = 2300, res=400)

df %>% 
  mutate(OVLabel = fct_relevel(OVLabel, 
           "Next Cancer",  "Interval Cancer", "Cancer", "False Positive Recall", "Recall")) %>% 
ggplot( aes(y=OVLabel, x=OR, xmin=LB, xmax=UB, col=`Screen Type`,fill=`Screen Type`))+
  #Add data points and color them black
 ggtitle("Reader Number - Two Reader \n (vs One Reader)") +
  xlab("OR") + ylab("Outcome") +  geom_linerange(size=1,position=position_dodge(width = 0.5)) +
  geom_vline(xintercept = 1) + geom_point(size=2, shape=21, colour="white", stroke = 0.5,position=position_dodge(width = 0.5)) + theme(legend.position="top")  + facet_wrap(~ TimeRange, ncol = 3) + coord_trans(x = "log") + facet_wrap(~TimeRange,  ncol = 4) + theme(axis.text.x = element_text(angle = 90))

invisible(dev.off())


#More sensitivity stuff

OutcomeVariables <- c("Recall", "FalsePositiveRecall", "Cancer", "IntervalCancer", "IntervalCancer2", "NextCancer")

 SP  <- c( "Type", "InvasiveType", "Size", "SDInvasiveSize", "SDDCISSize", "StageNum", "TStageNum", "NStageNum",   "SDNumberOfNodes1Num",  "NPI",  "MStage", "InvasiveGradeNum")

ScreenTypeList <- c( "Incident")
NotOR <- c( "Size", "SDInvasiveSize", "SDDCISSize", "NPI")


df <- NULL


 TimeRange <- c("Year ST Centres", "2080 Exclude 1", "2080 Exclude 2")
  

   for(Time in TimeRange){
     
for(OV in OutcomeVariables){
  
  for (ST in ScreenTypeList) {
    
    filename <- ifelse(OV %in% SP, paste0("C:\\Users\\u4111872\\Downloads\\UGH\\Models\\","DOVT1M1Screened", OV, ST, Time, ".xlsx"), paste0("C:\\Users\\u4111872\\Downloads\\UGH\\Models\\","DOVT1M1", OV, ST, Time, ".xlsx") )
                       
     modeltable <- xlsx::read.xlsx(filename, sheetName="Sheet1")


     variable <- c(paste0(OV))
     stat <- c(paste0(modeltable[modeltable$Variable == 'relevel(as.factor(Group), ref = "One reader")More than one reader',][,2]))
     ORType <- ifelse(OV %in% NotOR, "Not OR", "OR")
     TimeRange <- Time
     modeltablesave <- data.frame(variable, stat, ORType, TimeRange)
     df <- rbind(df, modeltablesave)
     
    
  }} }

#Get OR and hl and ul from df
df$OR <- str_split_fixed(df$stat, "\\(", 2)[,1]
df$Clean1 <- str_match_all(df$stat, "(?<=\\().+?(?=\\,)")
df$Clean2 <- ifelse(substr(df$Clean1, 1, 1) == "-", sub("^.", "N", df$Clean1), df$Clean1)

df$LB <- str_split_fixed(df$Clean2 , "-", 2)[,1]
df$UB <- str_split_fixed(df$Clean2 , "-", 2)[,2]

df$LB <- gsub("N", "-", df$LB) 
df$OR <- as.numeric(df$OR)
df$LB <- as.numeric(df$LB)
df$UB <- as.numeric(df$UB)

df$OR <- ifelse(df$ORType == "Not OR", exp(df$OR), df$OR)
df$LB <- ifelse(df$ORType == "Not OR", exp(df$LB), df$LB)
df$UB <- ifelse(df$ORType == "Not OR", exp(df$UB), df$UB)



dfIncident <- df


#And first screen

ScreenTypeList <- c( "Prevalent")
NotOR <- c( "Size", "SDInvasiveSize", "SDDCISSize", "NPI")



df <- NULL



 TimeRange <- c("Year ST Centres", "2080 Exclude 1", "2080 Exclude 2")
  

   for(Time in TimeRange){

for(OV in OutcomeVariables){
  
  for (ST in ScreenTypeList) {
    
    filename <- ifelse(OV %in% SP, paste0("C:\\Users\\u4111872\\Downloads\\UGH\\Models\\","DOVT1M1Screened", OV, ST, Time, ".xlsx"), paste0("C:\\Users\\u4111872\\Downloads\\UGH\\Models\\","DOVT1M1", OV, ST, Time, ".xlsx") )
                       
     modeltable <- xlsx::read.xlsx(filename, sheetName="Sheet1")


     variable <- c(paste0(OV))
     stat <- c(paste0(modeltable[modeltable$Variable == 'relevel(as.factor(Group), ref = "One reader")More than one reader',][,2]))
     ORType <- ifelse(OV %in% NotOR, "Not OR", "OR")
     TimeRange <- Time
     modeltablesave <- data.frame(variable, stat, ORType, TimeRange)
     df <- rbind(df, modeltablesave)
     
    
  }} }

df$OR <- str_split_fixed(df$stat, "\\(", 2)[,1]
df$Clean1 <- str_match_all(df$stat, "(?<=\\().+?(?=\\,)")
df$Clean2 <- ifelse(substr(df$Clean1, 1, 1) == "-", sub("^.", "N", df$Clean1), df$Clean1)

df$LB <- str_split_fixed(df$Clean2 , "-", 2)[,1]
df$UB <- str_split_fixed(df$Clean2 , "-", 2)[,2]

df$LB <- gsub("N", "-", df$LB) 
df$OR <- as.numeric(df$OR)
df$LB <- as.numeric(df$LB)
df$UB <- as.numeric(df$UB)

df$OR <- ifelse(df$ORType == "Not OR", exp(df$OR), df$OR)
df$LB <- ifelse(df$ORType == "Not OR", exp(df$LB), df$LB)
df$UB <- ifelse(df$ORType == "Not OR", exp(df$UB), df$UB)





dfPrevalent  <- df



#Make all in one graph
dfIncident$Group <- "Incident"
dfPrevalent $Group <- "Prevalent"

df <- rbind(dfIncident, dfPrevalent )


#Change labeling
df$OVLabel <- ifelse(df$variable == "FalsePositiveRecall", "False Positive Recall",
            ifelse(df$variable == "IntervalCancer", "Interval Cancer",     
             ifelse(df$variable == "NextCancer", "Next Cancer", 
             ifelse(df$variable == "Type", "Invasive Cancer (vs DCIS)",
            ifelse(df$variable == "InvasiveType", "Invasive ductal carcinoma \n (vs invasive lobular carcinoma)",     
            ifelse(df$variable == "Size", "Size (mm)",    
            ifelse(df$variable == "SDInvasiveSize", "Size (mm) invasive cancers",    
            ifelse(df$variable == "SDDCISSize", "Size (mm) DCIS cancer",
            ifelse(df$variable == "StageNum", "Stage (1 vs 2-4)",
            ifelse(df$variable == "TStageNum", "T Stage (1 vs 2-4)",
            ifelse(df$variable == "NStageNum", "N Stage (0 vs 1-3)",
            ifelse(df$variable == "MStage", "M Stage 1 (vs 0)",
            ifelse(df$variable == "InvasiveGradeNum", "Invasive Grade G1 (vs G2-G3)",
            ifelse(df$variable == "SDNumberOfNodes1Num", "Number of Nodes (0 vs more than 0)",
            ifelse(df$variable == "HormonalStatus", "Hormonal Status ER+HER2 (vs other combinations)", df$variable)))))))))))))))


screeninglist <- c("FalsePositiveRecall", "IntervalCancer", "NextCancer", "Recall", "Cancer")
df <- df %>% filter(variable %in% screeninglist)



df$`Screen Type` <- df$Group

#only the screening outcomes graph but for the sensitivity parts

jpeg("C:\\Users\\u4111872\\Downloads\\UGH\\graphs\\effectsizereadernumberplottimerange235sens.png", width = 3200, height = 2300, res=400)

df %>% 
  mutate(OVLabel = fct_relevel(OVLabel, 
           "Next Cancer",  "Interval Cancer", "Cancer", "False Positive Recall", "Recall")) %>% 
ggplot( aes(y=OVLabel, x=OR, xmin=LB, xmax=UB, col=`Screen Type`,fill=`Screen Type`))+
  #Add data points and color them black
 ggtitle("Reader Number - Two Reader \n (vs One Reader)") +
  xlab("OR") + ylab("Outcome") +  geom_linerange(size=1,position=position_dodge(width = 0.5)) +
  geom_vline(xintercept = 1) + geom_point(size=2, shape=21, colour="white", stroke = 0.5,position=position_dodge(width = 0.5)) + theme(legend.position="top")  + facet_wrap(~ TimeRange, ncol = 3) + coord_trans(x = "log") + facet_wrap(~TimeRange,  ncol = 4) + theme(axis.text.x = element_text(angle = 90))

invisible(dev.off())



```



# Reader Match Analysis One and two reader by reader id ALL YEARS


```{r onetworeadermatchanalysisworkingcodenow, out.width='100%', results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}

#This code pull put film readers who have at least 1k reading as single and part of a pair and then compared their screening outcomes, there's also a paired t-test for this


#Clearing memory 
invisible(gc())


#Importing needed variables from the patient level table
  creadlist <- c("PATIENTID", "FirstScreenID", "LastAgeOffered", "LastOfferEpisode" )
table0 <- read.fst("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\Table0.fst", columns = creadlist)

#Pulling in data from table 2
   creadlist <- c( "EPISODEID", "PATIENTID", "OfficeID", "CANCEROUTCOMEFLAG", "dateoffirstofferedappointmentcalc", "datetakencalc", "AgeCalc", "Screened", "Attender3")
    readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedA.fst"
table2 <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)


exclusion <- read.csv("C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\episodeexcludelist.csv")

table2$Year <- lubridate::year(table2$dateoffirstofferedappointmentcalc)

table2 <- table2 %>% filter(EPISODEID %notin% exclusion$EPISODEID & Screened == 1)

    table2$LastAgeOffered = table0$LastAgeOffered[match(table2$PATIENTID, table0$PATIENTID)]
      table2$IMDQUINTILE = table0$IMDQUINTILE[match(table2$PATIENTID, table0$PATIENTID)]
      

table2$ScreenTypeLast <- ifelse(table2$EPISODEID %in% table0$FirstScreenID, "Prevalent ",
                      ifelse(table2$EPISODEID %in% table0$LastOfferEpisode & table2$LastAgeOffered > 61, "Last",   "Incident"    ))

table2$ScreenType <- ifelse(table2$EPISODEID %in% table0$FirstScreenID, "Prevalent",   "Incident"    )


#rm(table0)
rm(exclusion)

#Film reader information
  readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedC.fst"
 creadlist <- c("EPISODEID",  "ReaderNum4", "FILMREADER1", "FILMREADERCAT1", "FILMREADER2", "FILMREADERCAT2")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2$ReaderNum4 = table2a$ReaderNum4[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$FILMREADER1 = table2a$FILMREADER1[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$FILMREADERCAT1 = table2a$FILMREADERCAT1[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$FILMREADER2 = table2a$FILMREADER2[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$FILMREADERCAT2 = table2a$FILMREADERCAT2[match(table2$EPISODEID, table2a$EPISODEID)]
 rm(table2a)

   readlink <- "C:\\Users\\u4111872\\Downloads\\UGH\\Join tables\\table2CalJoinedB.fst"
 creadlist <- c("EPISODEID",  "Recall", "FalsePositiveRecall")
 table2a <- read.fst(readlink, columns = creadlist, from = fromnum, to = tonum)

    table2$Recall = table2a$Recall[match(table2$EPISODEID, table2a$EPISODEID)]
        table2$FalsePositiveRecall = table2a$FalsePositiveRecall[match(table2$EPISODEID, table2a$EPISODEID)]
 rm(table2a)

 table2$Cancer <- ifelse(table2$CANCEROUTCOMEFLAG == "Y", 1,
                    ifelse(table2$CANCEROUTCOMEFLAG == "N", 0,  NA    ))

table2$Recall <- ifelse(table2$Recall == 1, 1, 0)
table2$FalsePositiveRecall <- ifelse(table2$FalsePositiveRecall == 1, 1, 0)


 table2$Group <- ifelse(table2$ReaderNum4 == 1, "One reader", ifelse(table2$ReaderNum4 > 1, "More than one reader", NA))
 

 table2$OfficeID1Plus <- ifelse(table2$OfficeID == "S032", "S006",
                          ifelse(table2$OfficeID == "S050", "S009",
                              ifelse(table2$OfficeID == "S077", "S079",
                                  ifelse(table2$OfficeID == "S078", "S071",
                                    ifelse(table2$OfficeID == "S081", "S071",
                                        ifelse(table2$OfficeID == "S083", "S021",
                                          ifelse(table2$OfficeID == "S084", "S079",
                                              ifelse(table2$OfficeID == "S027", "S023",
                                                  ifelse(table2$OfficeID == "S061", "S015",
                                                      ifelse(table2$OfficeID == "S007", "S074", table2$OfficeID
                                                              ))))))))))
       rm(table0)
 
 table2Original <- table2
#This gets reader information
 
 #Get first reader table
table2firstreader <- table2 %>% dplyr::select(EPISODEID, ScreenType, FILMREADER1, FILMREADERCAT1, dateoffirstofferedappointmentcalc, ReaderNum4, Group, Cancer, Screened,  Recall, FalsePositiveRecall)
table2firstreader$FILMREADER <- table2firstreader$FILMREADER1
table2firstreader$FILMREADER1 <- NULL
table2firstreader$FILMREADERCAT <- table2firstreader$FILMREADERCAT1
table2firstreader$FILMREADERCAT1 <- NULL

#Second reader information
table2secreader <- table2 %>% dplyr::select(EPISODEID, ScreenType, FILMREADER2, FILMREADERCAT2, dateoffirstofferedappointmentcalc, ReaderNum4, Group, Cancer, Screened,  Recall, FalsePositiveRecall)
table2secreader$FILMREADER <- table2secreader$FILMREADER2
table2secreader$FILMREADER2 <- NULL
table2secreader$FILMREADERCAT <- table2secreader$FILMREADERCAT2
table2secreader$FILMREADERCAT2 <- NULL

#Combine to make film readers long form
table2readersORG <- rbind(table2firstreader, table2secreader)

#Make sure film readers aren't in nameless list and aren't consensus readers
table2readersORG <- table2readersORG %>% filter(FILMREADER %notin% nameless)


 table2readersORGOriginal <- table2readersORG
 cat("table2readersORGOriginal saved: rows =",
    nrow(table2readersORGOriginal), "\n")

gc()


#Most analysis focused on screening recall outcome but here since we can match readers we can also look at individual reader decisions which may or may not be the same as the screening outcome 
table2readersORG$RecallDecision <- ifelse(table2readersORG$FILMREADERCAT == "RC/FV", 1, 0)


#I didn't bother trying to fit this all in a neat table so results are kind of all over the place which is why I have print headings here and there
print("THIS IS THE PREVALENT SCREENS, NEED AT LEAST 1k")

#This gets the prevalent screens
table2readers <- table2readersORG %>% filter(Screened == 1 & ScreenType == "Prevalent")

#Notes if the readers were reading in a pair or as a group
table2readers$OneReader <- ifelse(table2readers$Group == "One reader", 1, 0)
table2readers$TwoReader <- ifelse(table2readers$Group == "More than one reader", 1, 0)

#This gets the number of screens a film reader has read by either a solo reader or as a pair of readers
readersummary <- setDT(table2readers)[, .(.N,  OneReaderSum = sum(OneReader, na.rm = TRUE),  TwoReaderSum = sum(TwoReader, na.rm = TRUE)), by = .(FILMREADER)]

#We are looking only at film readers that have at least 1000 screens in each category
readersummarysample <-   readersummary %>% filter(OneReaderSum > 999 & TwoReaderSum > 999)

readersummarysampleOriginal <- readersummarysample
 cat("readersummarysampleOriginal saved: rows =",
    nrow(readersummarysampleOriginal), "\n")

#Creating two separate lists, one with one reader screens and one with two reader screens and with film readers with at least 1000 prevalent screens as each
table2readerssub1 <- table2readers %>% filter(FILMREADER %in% readersummarysample$FILMREADER & Group == "One reader")
table2readerssub2 <- table2readers %>% filter(FILMREADER %in% readersummarysample$FILMREADER & Group == "More than one reader")


#This gets the mean recall rate, recall decision, false positive, and cancer outcomes for the 1 reader screen grouped by film reader
readersummary1 <- setDT(table2readerssub1)[, .(.N,   RecallRate1 = mean(RecallDecision, na.rm = TRUE)*100, RecallDecision1 = mean(Recall, na.rm = TRUE)*100,  FalsePositiveRecallRate1 = mean(FalsePositiveRecall, na.rm = TRUE)*100, CancerRate1 = mean(Cancer, na.rm = TRUE)*100), by = .(FILMREADER)]

#I change the N variable here to be N1 (number of screens as one reader)
readersummary1$N1 <- readersummary1$N
readersummary1$N <- NULL

#This does the same as abouve but for the two reader screens
readersummary2 <- setDT(table2readerssub2)[, .(.N,  RecallRate2 = mean(RecallDecision, na.rm = TRUE)*100, RecallDecision2 = mean(Recall, na.rm = TRUE)*100,  FalsePositiveRecallRate2 = mean(FalsePositiveRecall, na.rm = TRUE)*100, CancerRate2 = mean(Cancer, na.rm = TRUE)*100), by = .(FILMREADER)]


readersummary2$N2 <- readersummary2$N
readersummary2$N <- NULL

#Create wide form dataset linking by FILMREADER ID
readersummary12<-merge(x=readersummary1,y=readersummary2,by="FILMREADER",all.x=TRUE)
#Pretty sure I already excluded those with less than 1k reads but making sure again here
readersummary12 <- readersummary12 %>% filter(N1 > 999 & N2 > 999)

#This is the descriptive table for screening outcomes by reader 1 and reader 2
print("Prevalent all screens for readers")
readersummary12 %>% dplyr::select(-FILMREADER) %>% tbl_summary(digits = list(everything()~c(RRound)), statistic = list(all_continuous() ~ "{mean} ({sd})"))

#I then also calculate the difference between the outcomes and do another descriptive table, this one only looks at difference
readersummary12Dif <- readersummary12
readersummary12Dif$RecallRateDif <- readersummary12Dif$RecallRate1 - readersummary12Dif$RecallRate2
readersummary12Dif$RecallDecisionDif <- readersummary12Dif$RecallDecision1 - readersummary12Dif$RecallDecision2
readersummary12Dif$FalsePositiveRecallRateDif <- readersummary12Dif$FalsePositiveRecallRate1 - readersummary12Dif$FalsePositiveRecallRate2
readersummary12Dif$CancerRateDif <- readersummary12Dif$CancerRate1 - readersummary12Dif$CancerRate2


readersummary12Dif %>% dplyr::select(N1, N2, RecallRateDif, RecallDecisionDif, FalsePositiveRecallRateDif, CancerRateDif)  %>% tbl_summary(digits = list(everything()~c(RRound)), statistic = list(all_continuous() ~ "{mean} ({sd})"))

#Here I just print out the t-tests for the four outcomes 
print("t tests")
t.test(readersummary12$RecallDecision1, readersummary12$RecallDecision2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$RecallRate1, readersummary12$RecallRate2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$FalsePositiveRecallRate1, readersummary12$FalsePositiveRecallRate2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$CancerRate1, readersummary12$CancerRate2, paired = TRUE, alternative = "two.sided")




#Because we are looking at screens that could have been a decade or more apart I also do another analysis were within each of these readers I look for the 1 year point where they had approximately even one and two reader screens to focus on and then also require that group of readers to have at least 1k screens in this 1 year period (this is only about 50 readers sadly)



#Subset dataset again 
table2readerssub <- table2readers %>% filter(FILMREADER %in% readersummarysample$FILMREADER)


table2readerssubOriginal <- table2readerssub

 cat("table2readerssubOriginal saved: rows =",
    nrow(table2readerssubOriginal), "\n")

#Create a blank dataframe
 RMtable <- NULL
  
 
 #Make group into a group number so we can calculating rolling mean by film reader  
  table2readerssub$GroupNum <-  ifelse(table2readerssub$Group == "More than one reader", 1, 0)
  
  #Library needed to calculate rolling means
  library(runner)

  #Create a loop that goes through every film reader in the above dataset
  for(OID in unique(table2readerssub$FILMREADER)) {


#Select only the variable needed, filter to only one film reader, then arrange by date     
table2test <-table2readerssub %>% dplyr::select(EPISODEID, FILMREADER, GroupNum, dateoffirstofferedappointmentcalc) %>%  filter(FILMREADER == OID) %>% arrange(dateoffirstofferedappointmentcalc, EPISODEID)

#This is a command that creates a running mean of group number (so proportion of more than 1 reader)
table2test$RM365 <- mean_run(x = table2test$GroupNum, k = 365, lag = 1, idx = as.Date(table2test$dateoffirstofferedappointmentcalc), na_rm = TRUE)

#This is to get the lower limit of date and adds a year (so I can filter out those who don't have at least a year of data), I don't think I actually need this as I check for at least a year of data later
table2test$UL365 <- min(table2test$dateoffirstofferedappointmentcalc) + 365

#If the rolling mean is within the first year replace with blank
table2test$RM365 <- ifelse(table2test$dateoffirstofferedappointmentcalc < table2test$UL365, NA, table2test$RM365)

#Then add a tag that will check if the rolling mean is at least 50%
table2test$Fifty365 <- ifelse(table2test$RM365 > .4999999999, 1, 0)

#Add these episodes to the dataset then move onto the next reader 
RMtable <- rbind(RMtable, table2test)

  }
  
  
  RMtableOriginal <- RMtable

   cat("RMtableOriginal saved: rows =",
    nrow(RMtableOriginal), "\n")
   
  
 RMIdenticalCheckOriginal <-  identical(
  sort(unique(RMtable$EPISODEID)),
  sort(unique(table2readerssub$EPISODEID))
)
 
 print(RMIdenticalCheckOriginal)
 
 #Match the rolling mean and tage to the other datafile
   # table2readerssub$RM365 = RMtable$RM365[match(table2readerssub$EPISODEID, RMtable$EPISODEID)]
   #     # table2readerssub$UL365 = RMtable$UL365[match(table2readerssub$EPISODEID, RMtable$EPISODEID)]
   #      table2readerssub$Fifty365 = RMtable$Fifty365[match(table2readerssub$EPISODEID, RMtable$EPISODEID)]

     table2readerssub <- left_join(
  table2readerssub,
  RMtable %>% dplyr::select(EPISODEID, FILMREADER, RM365, Fifty365),
  by = c("EPISODEID", "FILMREADER")
)
 
 #Filter to only screens where it is 50% and then get the first screen that happens to by film reader 
table2firstepi365 <- table2readerssub %>% filter(Fifty365 == 1) %>% 
  group_by(FILMREADER) %>%
  arrange(dateoffirstofferedappointmentcalc, EPISODEID) %>%
  dplyr::slice(1) %>%
  ungroup

#Here I create a date range variable for the past year of screens from the first point where a film reader has read 50% of their screens as two reader
table2firstepi365$DateMin365 <- table2firstepi365$dateoffirstofferedappointmentcalc-365
table2firstepi365$DateMax365 <- table2firstepi365$dateoffirstofferedappointmentcalc

#I then just look at the earliest screen (technically 2nd earliest) the get that information
table2firstepi365first <- table2readerssub %>% filter(!is.na(Fifty365)) %>% 
  group_by(FILMREADER) %>%
  arrange(dateoffirstofferedappointmentcalc, EPISODEID) %>%
  dplyr::slice(1) %>%
  ungroup

#I create a tag where if the 1000th screen already has more than 50% 2 reader then it is tagged as one, these are excluded later
table2firstepi365first$Tag365 <- ifelse(table2firstepi365first$RM365 > .50, 1, 0)

#Match this new information to other dataset
        table2readerssub$DateMin365 = table2firstepi365$DateMin365[match(table2readerssub$FILMREADER, table2firstepi365$FILMREADER)]
        table2readerssub$DateMax365 = table2firstepi365$DateMax365[match(table2readerssub$FILMREADER, table2firstepi365$FILMREADER)]
        table2readerssub$Tag365 = table2firstepi365first$Tag365[match(table2readerssub$FILMREADER, table2firstepi365first$FILMREADER)]

    table2readerssubOriginal1 <- table2readerssub
    
       cat("table2readerssubOriginal1 saved: rows =",
    nrow(table2readerssubOriginal1), "\n")
    
print("This is still prevalent but now only focused on the 1 year around each reader")
print("Number of unique readers")

#Then I filter to the reader group where the screening range is the year if the 1000th screen isn't alrady more than 50% two reader
table2readerssub <- table2readerssub %>% filter(dateoffirstofferedappointmentcalc <= DateMax365 & dateoffirstofferedappointmentcalc > DateMin365 & Tag365 == 0)

 table2readerssubOriginal2 <- table2readerssub
 
        cat("table2readerssubOriginal2 saved: rows =",
    nrow(table2readerssubOriginal2), "\n")

#Looking at my pitful sample of readers here
length(unique(table2readerssub$FILMREADER))

#Also looking at how 1 and 2 reader groups are not even (because I don't take the past 1000 screens I take the previous year which allows for a mismatch of 1 and 2 reader screens)
print("Group breakdown, not even because it's by date I guess?")
table(table2readerssub$Group)


#Much the same calculation just now with this smaller sample
table2readerssub1 <- table2readerssub %>% filter(Group == "One reader")
table2readerssub2 <- table2readerssub %>% filter(Group == "More than one reader")


readersummary1 <- setDT(table2readerssub1)[, .(.N,   RecallRate1 = mean(RecallDecision, na.rm = TRUE)*100, RecallDecision1 = mean(Recall, na.rm = TRUE)*100,  FalsePositiveRecallRate1 = mean(FalsePositiveRecall, na.rm = TRUE)*100, CancerRate1 = mean(Cancer, na.rm = TRUE)*100), by = .(FILMREADER)]

readersummary1$N1 <- readersummary1$N
readersummary1$N <- NULL

readersummary2 <- setDT(table2readerssub2)[, .(.N,  RecallRate2 = mean(RecallDecision, na.rm = TRUE)*100, RecallDecision2 = mean(Recall, na.rm = TRUE)*100,  FalsePositiveRecallRate2 = mean(FalsePositiveRecall, na.rm = TRUE)*100, CancerRate2 = mean(Cancer, na.rm = TRUE)*100), by = .(FILMREADER)]


readersummary2$N2 <- readersummary2$N
readersummary2$N <- NULL

readersummary12<-merge(x=readersummary1,y=readersummary2,by="FILMREADER",all.x=TRUE)
readersummary12 <- readersummary12 %>% filter(N1 > 999 & N2 > 999)

readersummary12 %>% dplyr::select(-FILMREADER) %>% tbl_summary(digits = list(everything()~c(RRound)), statistic = list(all_continuous() ~ "{mean} ({sd})"))


 readersummary12Original <- readersummary12
 
         cat("readersummary12Original saved: rows =",
    nrow(readersummary12Original), "\n")

readersummary12Dif <- readersummary12
readersummary12Dif$RecallRateDif <- readersummary12Dif$RecallRate1 - readersummary12Dif$RecallRate2
readersummary12Dif$RecallDecisionDif <- readersummary12Dif$RecallDecision1 - readersummary12Dif$RecallDecision2
readersummary12Dif$FalsePositiveRecallRateDif <- readersummary12Dif$FalsePositiveRecallRate1 - readersummary12Dif$FalsePositiveRecallRate2
readersummary12Dif$CancerRateDif <- readersummary12Dif$CancerRate1 - readersummary12Dif$CancerRate2

readersummary12Dif %>% dplyr::select(N1, N2, RecallRateDif, RecallDecisionDif, FalsePositiveRecallRateDif, CancerRateDif) %>% tbl_summary(digits = list(everything()~c(RRound)), statistic = list(all_continuous() ~ "{mean} ({sd})"))



t.test(readersummary12$RecallDecision1, readersummary12$RecallDecision2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$RecallRate1, readersummary12$RecallRate2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$FalsePositiveRecallRate1, readersummary12$FalsePositiveRecallRate2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$CancerRate1, readersummary12$CancerRate2, paired = TRUE, alternative = "two.sided")













#I didn't bother trying to fit this all in a neat table so results are kind of all over the place which is why I have print headings here and there
print("THIS IS THE INCIDENT SCREENS, NEED AT LEAST 1k")

#This gets the prevalent screens
table2readers <- table2readersORG %>% filter(Screened == 1 & ScreenType == "Incident")

#Notes if the readers were reading in a pair or as a group
table2readers$OneReader <- ifelse(table2readers$Group == "One reader", 1, 0)
table2readers$TwoReader <- ifelse(table2readers$Group == "More than one reader", 1, 0)

#This gets the number of screens a film reader has read by either a solo reader or as a pair of readers
readersummary <- setDT(table2readers)[, .(.N,  OneReaderSum = sum(OneReader, na.rm = TRUE),  TwoReaderSum = sum(TwoReader, na.rm = TRUE)), by = .(FILMREADER)]

#We are looking only at fil readers that have at least 1000 screens in each category
readersummarysample <-   readersummary %>% filter(OneReaderSum > 999 & TwoReaderSum > 999)

readersummarysampleOriginal <- readersummarysample
 cat("readersummarysampleOriginal saved: rows =",
    nrow(readersummarysampleOriginal), "\n")

#Creating two seperate lists, one with one reader screens and one with two reader screens and with film readers with at least 1000 prevalent screens as each
table2readerssub1 <- table2readers %>% filter(FILMREADER %in% readersummarysample$FILMREADER & Group == "One reader")
table2readerssub2 <- table2readers %>% filter(FILMREADER %in% readersummarysample$FILMREADER & Group == "More than one reader")


#This gets the mean recall rate, recall decision, false positive, and cancer outcomes for the 1 reader screen grouped by film reader
readersummary1 <- setDT(table2readerssub1)[, .(.N,   RecallRate1 = mean(RecallDecision, na.rm = TRUE)*100, RecallDecision1 = mean(Recall, na.rm = TRUE)*100,  FalsePositiveRecallRate1 = mean(FalsePositiveRecall, na.rm = TRUE)*100, CancerRate1 = mean(Cancer, na.rm = TRUE)*100), by = .(FILMREADER)]

#I change the N variable here to be N1 (number of screens as one reader)
readersummary1$N1 <- readersummary1$N
readersummary1$N <- NULL

#This does the same as abouve but for the two reader screens
readersummary2 <- setDT(table2readerssub2)[, .(.N,  RecallRate2 = mean(RecallDecision, na.rm = TRUE)*100, RecallDecision2 = mean(Recall, na.rm = TRUE)*100,  FalsePositiveRecallRate2 = mean(FalsePositiveRecall, na.rm = TRUE)*100, CancerRate2 = mean(Cancer, na.rm = TRUE)*100), by = .(FILMREADER)]


readersummary2$N2 <- readersummary2$N
readersummary2$N <- NULL

#Create wide form dataset linking by FILMREADER ID
readersummary12<-merge(x=readersummary1,y=readersummary2,by="FILMREADER",all.x=TRUE)
#Pretty sure I already excluded those with less than 1k reads but making sure again here
readersummary12 <- readersummary12 %>% filter(N1 > 999 & N2 > 999)

#This is the descriptive table for screening outcomes by reader 1 and reader 2
print("Prevalent all screens for readers")
readersummary12 %>% dplyr::select(-FILMREADER) %>% tbl_summary(digits = list(everything()~c(RRound)), statistic = list(all_continuous() ~ "{mean} ({sd})"))

#I then also calculate the difference between the outcomes and do another descriptive table, this one only looks at difference
readersummary12Dif <- readersummary12
readersummary12Dif$RecallRateDif <- readersummary12Dif$RecallRate1 - readersummary12Dif$RecallRate2
readersummary12Dif$RecallDecisionDif <- readersummary12Dif$RecallDecision1 - readersummary12Dif$RecallDecision2
readersummary12Dif$FalsePositiveRecallRateDif <- readersummary12Dif$FalsePositiveRecallRate1 - readersummary12Dif$FalsePositiveRecallRate2
readersummary12Dif$CancerRateDif <- readersummary12Dif$CancerRate1 - readersummary12Dif$CancerRate2


readersummary12Dif %>% dplyr::select(N1, N2, RecallRateDif, RecallDecisionDif, FalsePositiveRecallRateDif, CancerRateDif)  %>% tbl_summary(digits = list(everything()~c(RRound)), statistic = list(all_continuous() ~ "{mean} ({sd})"))

#Here I just print out the t-tests for the four outcomes 
print("t tests")
t.test(readersummary12$RecallDecision1, readersummary12$RecallDecision2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$RecallRate1, readersummary12$RecallRate2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$FalsePositiveRecallRate1, readersummary12$FalsePositiveRecallRate2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$CancerRate1, readersummary12$CancerRate2, paired = TRUE, alternative = "two.sided")




#Because we are looking at screens that could have been a decade or more apart I also do another analysis were within each of these readers I look for the 1 year point where they had approximately even one and two reader screens to focus on and then also require that group of readers to have at least 1k screens in this 1 year period (this is only about 50 readers sadly)



#Subset dataset again 
table2readerssub <- table2readers %>% filter(FILMREADER %in% readersummarysample$FILMREADER)


table2readerssubOriginal <- table2readerssub

 cat("table2readerssubOriginal saved: rows =",
    nrow(table2readerssubOriginal), "\n")

#Create a blank dataframe
 RMtable <- NULL
  
 
 #Make group into a group number so we can calculating rolling mean by film reader  
  table2readerssub$GroupNum <-  ifelse(table2readerssub$Group == "More than one reader", 1, 0)
  
  #Library needed to calculate rolling means
  library(runner)

  #Create a loop that goes through every film reader in the above dataset
  for(OID in unique(table2readerssub$FILMREADER)) {


#Select only the variable needed, filter to only one film reader, then arrange by date     
table2test <-table2readerssub %>% dplyr::select(EPISODEID, FILMREADER, GroupNum, dateoffirstofferedappointmentcalc) %>%  filter(FILMREADER == OID) %>% arrange(dateoffirstofferedappointmentcalc, EPISODEID)

#This is a command that creates a running mean of group number (so proportion of more than 1 reader)
table2test$RM365 <- mean_run(x = table2test$GroupNum, k = 365, lag = 1, idx = as.Date(table2test$dateoffirstofferedappointmentcalc), na_rm = TRUE)

#This is to get the lower limit of date and adds a year (so I can filter out those who don't have at least a year of data), I don't think I actually need this as I check for at least a year of data later
table2test$UL365 <- min(table2test$dateoffirstofferedappointmentcalc) + 365

#If the rolling mean is within the first year replace with blank
table2test$RM365 <- ifelse(table2test$dateoffirstofferedappointmentcalc < table2test$UL365, NA, table2test$RM365)

#Then add a tag that will check if the rolling mean is at least 50%
table2test$Fifty365 <- ifelse(table2test$RM365 > .4999999999, 1, 0)

#Add these episodes to the dataset then move onto the next reader 
RMtable <- rbind(RMtable, table2test)

  }
  
  
  RMtableOriginal <- RMtable

   cat("RMtableOriginal saved: rows =",
    nrow(RMtableOriginal), "\n")
   
  
 RMIdenticalCheckOriginal <-  identical(
  sort(unique(RMtable$EPISODEID)),
  sort(unique(table2readerssub$EPISODEID))
)
 
 print(RMIdenticalCheckOriginal)
 
 #Match the rolling mean and tage to the other datafile
   # table2readerssub$RM365 = RMtable$RM365[match(table2readerssub$EPISODEID, RMtable$EPISODEID)]
   #     # table2readerssub$UL365 = RMtable$UL365[match(table2readerssub$EPISODEID, RMtable$EPISODEID)]
   #      table2readerssub$Fifty365 = RMtable$Fifty365[match(table2readerssub$EPISODEID, RMtable$EPISODEID)]

     table2readerssub <- left_join(
  table2readerssub,
  RMtable %>% dplyr::select(EPISODEID, FILMREADER, RM365, Fifty365),
  by = c("EPISODEID", "FILMREADER")
)
 
 #Filter to only screens where it is 50% and then get the first screen that happens to by film reader 
table2firstepi365 <- table2readerssub %>% filter(Fifty365 == 1) %>% 
  group_by(FILMREADER) %>%
  arrange(dateoffirstofferedappointmentcalc, EPISODEID) %>%
  dplyr::slice(1) %>%
  ungroup

#Here I create a date range variable for the past year of screens from the first point where a film reader has read 50% of their screens as two reader
table2firstepi365$DateMin365 <- table2firstepi365$dateoffirstofferedappointmentcalc-365
table2firstepi365$DateMax365 <- table2firstepi365$dateoffirstofferedappointmentcalc

#I then just look at the earliest screen (technically 2nd earliest) the get that information
table2firstepi365first <- table2readerssub %>% filter(!is.na(Fifty365)) %>% 
  group_by(FILMREADER) %>%
  arrange(dateoffirstofferedappointmentcalc, EPISODEID) %>%
  dplyr::slice(1) %>%
  ungroup

#I create a tag where if the 1000th screen already has more than 50% 2 reader then it is tagged as one, these are excluded later
table2firstepi365first$Tag365 <- ifelse(table2firstepi365first$RM365 > .50, 1, 0)

#Match this new information to other dataset
        table2readerssub$DateMin365 = table2firstepi365$DateMin365[match(table2readerssub$FILMREADER, table2firstepi365$FILMREADER)]
        table2readerssub$DateMax365 = table2firstepi365$DateMax365[match(table2readerssub$FILMREADER, table2firstepi365$FILMREADER)]
        table2readerssub$Tag365 = table2firstepi365first$Tag365[match(table2readerssub$FILMREADER, table2firstepi365first$FILMREADER)]

    table2readerssubOriginal1 <- table2readerssub
    
       cat("table2readerssubOriginal1 saved: rows =",
    nrow(table2readerssubOriginal1), "\n")
    
print("This is still prevalent but now only focused on the 1 year around each reader")
print("Number of unique readers")

#Then I filter to the reader group where the screening range is the year if the 1000th screen isn't alrady more than 50% two reader
table2readerssub <- table2readerssub %>% filter(dateoffirstofferedappointmentcalc <= DateMax365 & dateoffirstofferedappointmentcalc > DateMin365 & Tag365 == 0)

 table2readerssubOriginal2 <- table2readerssub
 
        cat("table2readerssubOriginal2 saved: rows =",
    nrow(table2readerssubOriginal2), "\n")

#Looking at my pitful sample of readers here
length(unique(table2readerssub$FILMREADER))

#Also looking at how 1 and 2 reader groups are not even (because I don't take the past 1000 screens I take the previous year which allows for a mismatch of 1 and 2 reader screens)
print("Group breakdown, not even because it's by date I guess?")
table(table2readerssub$Group)


#Much the same calculation just now with this smaller sample
table2readerssub1 <- table2readerssub %>% filter(Group == "One reader")
table2readerssub2 <- table2readerssub %>% filter(Group == "More than one reader")


readersummary1 <- setDT(table2readerssub1)[, .(.N,   RecallRate1 = mean(RecallDecision, na.rm = TRUE)*100, RecallDecision1 = mean(Recall, na.rm = TRUE)*100,  FalsePositiveRecallRate1 = mean(FalsePositiveRecall, na.rm = TRUE)*100, CancerRate1 = mean(Cancer, na.rm = TRUE)*100), by = .(FILMREADER)]

readersummary1$N1 <- readersummary1$N
readersummary1$N <- NULL

readersummary2 <- setDT(table2readerssub2)[, .(.N,  RecallRate2 = mean(RecallDecision, na.rm = TRUE)*100, RecallDecision2 = mean(Recall, na.rm = TRUE)*100,  FalsePositiveRecallRate2 = mean(FalsePositiveRecall, na.rm = TRUE)*100, CancerRate2 = mean(Cancer, na.rm = TRUE)*100), by = .(FILMREADER)]


readersummary2$N2 <- readersummary2$N
readersummary2$N <- NULL

readersummary12<-merge(x=readersummary1,y=readersummary2,by="FILMREADER",all.x=TRUE)
readersummary12 <- readersummary12 %>% filter(N1 > 999 & N2 > 999)

readersummary12 %>% dplyr::select(-FILMREADER) %>% tbl_summary(digits = list(everything()~c(RRound)), statistic = list(all_continuous() ~ "{mean} ({sd})"))


 readersummary12Original <- readersummary12
 
         cat("readersummary12Original saved: rows =",
    nrow(readersummary12Original), "\n")

readersummary12Dif <- readersummary12
readersummary12Dif$RecallRateDif <- readersummary12Dif$RecallRate1 - readersummary12Dif$RecallRate2
readersummary12Dif$RecallDecisionDif <- readersummary12Dif$RecallDecision1 - readersummary12Dif$RecallDecision2
readersummary12Dif$FalsePositiveRecallRateDif <- readersummary12Dif$FalsePositiveRecallRate1 - readersummary12Dif$FalsePositiveRecallRate2
readersummary12Dif$CancerRateDif <- readersummary12Dif$CancerRate1 - readersummary12Dif$CancerRate2

readersummary12Dif %>% dplyr::select(N1, N2, RecallRateDif, RecallDecisionDif, FalsePositiveRecallRateDif, CancerRateDif) %>% tbl_summary(digits = list(everything()~c(RRound)), statistic = list(all_continuous() ~ "{mean} ({sd})"))



t.test(readersummary12$RecallDecision1, readersummary12$RecallDecision2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$RecallRate1, readersummary12$RecallRate2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$FalsePositiveRecallRate1, readersummary12$FalsePositiveRecallRate2, paired = TRUE, alternative = "two.sided")
t.test(readersummary12$CancerRate1, readersummary12$CancerRate2, paired = TRUE, alternative = "two.sided")




```



# Appendix stuff

```{r AppendixStuff, echo=FALSE}

#This just prints earlier tables so they will be in order

screeningoutcometable1
screeningoutcometable2
screeningoutcometable3
screeningoutcometable4
screeningoutcometable5
screeningoutcometable6


```





```{r Screen Models Cleaning2, out.width='100%', results = "asis", echo = FALSE, warning = FALSE, message = FALSE, fig.align="center"}

#This is the cleaning of the screen model analysis for the sensitivity analysis, code is much the same as before 



ScreenTypeList <- c("Prevalent ", "Incident")
OutcomeVariables <- c("Recall", "FalsePositiveRecall", "Cancer", "Cancer2", "IntervalCancer", "IntervalCancer1Y",  "NextCancer")
startcode <- Sys.time()
  TimeRange <- c( "Years0T", "Year", "Four", "Two", "Year ST Centres", "2080 Exclude 1", "2080 Exclude 2")
  

   for(Time in TimeRange){
     
     
for (OV in OutcomeVariables) {
for (ST in ScreenTypeList) {

outputfile <- paste0('C:\\Users\\u4111872\\Downloads\\UGH\\Models\\', "DOVT1M1", OV, ST, Time, '.xlsx')
     modeltable <- xlsx::read.xlsx(outputfile, sheetName="Sheet1")
    modelfootnote <- xlsx::read.xlsx(outputfile, sheetName="Sheet2")
    
    modeltable[nrow(modeltable) + 1,]  <- c("N", str_match(modelfootnote, "Number in model =\\s*(.*?)\\s*,")[2])

    
 colnames(modeltable)[colnames(modeltable) == "OR"] = paste0(ST)


 assign(  paste("modeltable", OV, ST, Time, sep = ""), modeltable )
 
 


} } }


  
       for(Time in TimeRange){
         
         modeltableout <- NULL
         
for (OV in OutcomeVariables) {

  
 modeltablePrevalent  <-  mget(paste0("modeltable", OV, "Prevalent ", Time))
 modeltablePrevalent  <- modeltablePrevalent [[1]]
 
  modeltableIncident <-  mget(paste0("modeltable", OV, "Incident", Time))
 modeltableIncident <- modeltableIncident[[1]]
 

 
#Join the three models
modeltable <- merge(x=modeltablePrevalent , y=modeltableIncident,by="Variable", all.x=TRUE)


#Clean up names and reorder
modeltable$Variable <- ifelse(modeltable$Variable == "as.factor(Group)One reader", "One reader",
                              
                              ifelse(modeltable$Variable == 'relevel(as.factor(Group), ref = "One reader")More than one reader', "Two reader",
                        ifelse(modeltable$Variable == "as.factor(Group)One reader:Threshold500P", "One reader*Log(Threshold)",
                         ifelse(modeltable$Variable == "Threshold500P", "Log(Threshold)",  
                                 ifelse(modeltable$Variable == "ReaderExp", "Reader Experience", 
                            ifelse(modeltable$Variable == "AgeCalc", "Age",     
                        
                                modeltable$Variable   ))))))


modeltable$Variable  <- factor(modeltable$Variable, levels=c("Age", "Year", "Reader Experience", "One reader", "Two reader", "N", "Groups", "AIC", "C-statistics"))

modeltable <- modeltable %>% arrange(Variable)



#Can rename OV here if needed to make it cleaner
OVLabel <- ifelse(OV == "FalsePositiveRecall", "False Positive Recall",
            ifelse(OV == "IntervalCancer", "Interval Cancer",     
             ifelse(OV == "NextCancer", "Next Cancer", OV
                  )))

#Put OVLabel as row I guess
OVLabelList <-c( OVLabel, OVLabel)

#Put prevalent and incident with N



 rowlabel <- c( "",
       paste0(colnames(modeltable)[2], "N=", prettyNum(modeltable[which(modeltable$Variable=="N"),]$Prevalent,big.mark=",",scientific=FALSE)),
       paste0(colnames(modeltable)[3], " N=", prettyNum(modeltable[which(modeltable$Variable=="N"),]$Incident,big.mark=",",scientific=FALSE))
       )
 

 
 modeltable <- modeltable %>% filter(Variable != "N")


modeltable <- rbind(rowlabel, modeltable)
modeltable <- rbind(OVLabelList, modeltable)

modeltableout <- rbind(modeltableout, modeltable)





rm(modeltable)

} 
         
         
 
         
              flextable_to_rmd(flextable(modeltableout) %>%   set_caption(caption = paste0("Table ", tablenum, ": Screening Outcomes ", " / Time: " , Time)) %>% add_footer_lines("Results show Odd's Ratio and 95% confidence intervals. A logistic multilevel model was used. For prevalent screenings the group measure shows the number of centres while for incident screenings the group measure shows the unique number of women/number of centres.")   %>% autofit())


       tablenum <- tablenum + 1
         
         
         }





        
```



```{r}

```


